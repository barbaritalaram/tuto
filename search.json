[
  {
    "objectID": "tuto_entero/AI-Companion/termino.html",
    "href": "tuto_entero/AI-Companion/termino.html",
    "title": "9. No es un Adi√≥s es un Hasta Pronto üëã",
    "section": "",
    "text": "Por el momento aqu√≠ terminamos, esperamos que hayas aprendido y puedas utilizar esta tecnolog√≠a. Iremos actualizando el tutorial cuando corresponda y reparando errores para poder mejorar este proyecto. No te desanimes y sigue adelante que eres genial en esto üòä. Si algo no te va, recuerda que me puedes encontrar en mi instagram o en mi correo.\nChau!\nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/01_tallerdebolsillo/01_3-pensarcomosistema.html",
    "href": "tuto_entero/01_tallerdebolsillo/01_3-pensarcomosistema.html",
    "title": "Cap√≠tulo 1 ¬∑ Hack Yourself: Dise√±a tu Sistema Interior",
    "section": "",
    "text": "Desde Plat√≥n a Maturana, la teor√≠a de sistemas propone que nada existe en aislamiento. Todo sistema tiene entradas, procesos, salidas y retroalimentaci√≥n.\n\n\n\n\n\n\nElemento\nEjemplos\n\n\n\n\nEntradas\nIdeas, est√≠mulos, relaciones, datos\n\n\nProcesos\nEmociones, h√°bitos, intuici√≥n, pensamiento\n\n\nSalidas\nDecisiones, obras, acciones\n\n\nRetroalimentaci√≥n\nReacciones del entorno, aprendizajes\n\n\n\ngraph TD\n  A[Entradas] --&gt; B[Procesos]\n  B --&gt; C[Salidas]\n  C --&gt; D[Retroalimentaci√≥n]\n  D --&gt; B\n\n\n\n\nAbre Kinopio\nMapea tus entradas, procesos, salidas y feedback\nUsa flechas y palabras clave para conectarlos\nColorea lo que quieras transformar, potenciar o eliminar\n\nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/01_tallerdebolsillo/01_3-pensarcomosistema.html#la-teor√≠a-de-sistemas-breve-historia",
    "href": "tuto_entero/01_tallerdebolsillo/01_3-pensarcomosistema.html#la-teor√≠a-de-sistemas-breve-historia",
    "title": "Cap√≠tulo 1 ¬∑ Hack Yourself: Dise√±a tu Sistema Interior",
    "section": "",
    "text": "Desde Plat√≥n a Maturana, la teor√≠a de sistemas propone que nada existe en aislamiento. Todo sistema tiene entradas, procesos, salidas y retroalimentaci√≥n."
  },
  {
    "objectID": "tuto_entero/01_tallerdebolsillo/01_3-pensarcomosistema.html#t√∫-como-sistema",
    "href": "tuto_entero/01_tallerdebolsillo/01_3-pensarcomosistema.html#t√∫-como-sistema",
    "title": "Cap√≠tulo 1 ¬∑ Hack Yourself: Dise√±a tu Sistema Interior",
    "section": "",
    "text": "Elemento\nEjemplos\n\n\n\n\nEntradas\nIdeas, est√≠mulos, relaciones, datos\n\n\nProcesos\nEmociones, h√°bitos, intuici√≥n, pensamiento\n\n\nSalidas\nDecisiones, obras, acciones\n\n\nRetroalimentaci√≥n\nReacciones del entorno, aprendizajes\n\n\n\ngraph TD\n  A[Entradas] --&gt; B[Procesos]\n  B --&gt; C[Salidas]\n  C --&gt; D[Retroalimentaci√≥n]\n  D --&gt; B"
  },
  {
    "objectID": "tuto_entero/01_tallerdebolsillo/01_3-pensarcomosistema.html#ejercicio-diagrama-de-tu-m√°quina-de-pensar",
    "href": "tuto_entero/01_tallerdebolsillo/01_3-pensarcomosistema.html#ejercicio-diagrama-de-tu-m√°quina-de-pensar",
    "title": "Cap√≠tulo 1 ¬∑ Hack Yourself: Dise√±a tu Sistema Interior",
    "section": "",
    "text": "Abre Kinopio\nMapea tus entradas, procesos, salidas y feedback\nUsa flechas y palabras clave para conectarlos\nColorea lo que quieras transformar, potenciar o eliminar\n\nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/01_tallerdebolsillo/01_2-elneorenacimientoytu.html",
    "href": "tuto_entero/01_tallerdebolsillo/01_2-elneorenacimientoytu.html",
    "title": "Cap√≠tulo 1 ¬∑ Hack Yourself: Dise√±a tu Sistema Interior",
    "section": "",
    "text": "Un per√≠odo donde el arte, la ciencia y el pensamiento humanista florecieron. Figuras como Da Vinci unificaban disciplinas y registraban su pensamiento en cuadernos complejos y visuales.\n\n\n\nHoy tenemos: - Acceso masivo al conocimiento (como la imprenta) - Exploraci√≥n interdisciplinaria (bioarte, neurodise√±o) - Tecnolog√≠a con prop√≥sito humano (IA √©tica) - Crisis globales que nos empujan a repensarlo todo\n\n\n\nEl centro vuelve a ser el ser humano. Pero esta vez, con la ayuda de algoritmos, redes, datos y sistemas de pensamiento expandido.\nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/01_tallerdebolsillo/01_2-elneorenacimientoytu.html#qu√©-fue-el-renacimiento",
    "href": "tuto_entero/01_tallerdebolsillo/01_2-elneorenacimientoytu.html#qu√©-fue-el-renacimiento",
    "title": "Cap√≠tulo 1 ¬∑ Hack Yourself: Dise√±a tu Sistema Interior",
    "section": "",
    "text": "Un per√≠odo donde el arte, la ciencia y el pensamiento humanista florecieron. Figuras como Da Vinci unificaban disciplinas y registraban su pensamiento en cuadernos complejos y visuales."
  },
  {
    "objectID": "tuto_entero/01_tallerdebolsillo/01_2-elneorenacimientoytu.html#por-qu√©-estamos-viviendo-un-neorenacimiento",
    "href": "tuto_entero/01_tallerdebolsillo/01_2-elneorenacimientoytu.html#por-qu√©-estamos-viviendo-un-neorenacimiento",
    "title": "Cap√≠tulo 1 ¬∑ Hack Yourself: Dise√±a tu Sistema Interior",
    "section": "",
    "text": "Hoy tenemos: - Acceso masivo al conocimiento (como la imprenta) - Exploraci√≥n interdisciplinaria (bioarte, neurodise√±o) - Tecnolog√≠a con prop√≥sito humano (IA √©tica) - Crisis globales que nos empujan a repensarlo todo"
  },
  {
    "objectID": "tuto_entero/01_tallerdebolsillo/01_2-elneorenacimientoytu.html#el-nuevo-humanismo-digital",
    "href": "tuto_entero/01_tallerdebolsillo/01_2-elneorenacimientoytu.html#el-nuevo-humanismo-digital",
    "title": "Cap√≠tulo 1 ¬∑ Hack Yourself: Dise√±a tu Sistema Interior",
    "section": "",
    "text": "El centro vuelve a ser el ser humano. Pero esta vez, con la ayuda de algoritmos, redes, datos y sistemas de pensamiento expandido.\nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/01_tallerdebolsillo/01-introduccion.html",
    "href": "tuto_entero/01_tallerdebolsillo/01-introduccion.html",
    "title": "Cap√≠tulo 1 ¬∑ Hack Yourself: Dise√±a tu Sistema Interior",
    "section": "",
    "text": "‚ÄúT√∫ eres el prompt. T√∫ dise√±as tu sistema. T√∫ decides tu prop√≥sito.‚Äù"
  },
  {
    "objectID": "tuto_entero/01_tallerdebolsillo/01-introduccion.html#qu√©-es-este-tutorial",
    "href": "tuto_entero/01_tallerdebolsillo/01-introduccion.html#qu√©-es-este-tutorial",
    "title": "Cap√≠tulo 1 ¬∑ Hack Yourself: Dise√±a tu Sistema Interior",
    "section": "¬øQu√© es este tutorial?",
    "text": "¬øQu√© es este tutorial?\nEste no es un tutorial t√©cnico sobre IA. Es un viaje personal para redise√±ar tu sistema interior con herramientas anal√≥gicas y digitales, con sentido, agencia y prop√≥sito."
  },
  {
    "objectID": "tuto_entero/01_tallerdebolsillo/01-introduccion.html#por-qu√©-redise√±ar-tu-sistema-interior",
    "href": "tuto_entero/01_tallerdebolsillo/01-introduccion.html#por-qu√©-redise√±ar-tu-sistema-interior",
    "title": "Cap√≠tulo 1 ¬∑ Hack Yourself: Dise√±a tu Sistema Interior",
    "section": "¬øPor qu√© redise√±ar tu sistema interior?",
    "text": "¬øPor qu√© redise√±ar tu sistema interior?\nVivimos en tiempos donde la atenci√≥n se fragmenta, la creatividad se terceriza y el conocimiento se dispersa. Este cap√≠tulo es un primer paso para construir tu cerebro digital neorenacentista."
  },
  {
    "objectID": "tuto_entero/01_tallerdebolsillo/01-introduccion.html#qu√©-aprender√°s-en-este-cap√≠tulo",
    "href": "tuto_entero/01_tallerdebolsillo/01-introduccion.html#qu√©-aprender√°s-en-este-cap√≠tulo",
    "title": "Cap√≠tulo 1 ¬∑ Hack Yourself: Dise√±a tu Sistema Interior",
    "section": "Qu√© aprender√°s en este cap√≠tulo",
    "text": "Qu√© aprender√°s en este cap√≠tulo\n\nPensar como sistema\nConectar entradas, procesos, salidas y feedback\nUsar herramientas como Obsidian y Kinopio para pensar mejor\n\nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/docker/05-conceptos-basicos.html",
    "href": "tuto_entero/docker/05-conceptos-basicos.html",
    "title": "5. Los Conceptos B√°sicos de los Contenedores üëÄ",
    "section": "",
    "text": "Para entender c√≥mo funciona Docker y aprovechar sus capacidades, es importante familiarizarse con algunos conceptos clave. A continuaci√≥n, explicaremos los elementos esenciales que componen esta tecnolog√≠a.\n\n\nUn contenedor es una instancia en ejecuci√≥n de una imagen. Es como una c√°psula autosuficiente dise√±ada para ejecutar una aplicaci√≥n de manera predecible y uniforme, sin importar el entorno donde se encuentre. Siguiendo con la analog√≠a del traje espacial üë©‚ÄçüöÄ, el contenedor encapsula la aplicaci√≥n junto con todas sus dependencias en un entorno aislado.\nEn t√©rminos t√©cnicos, un contenedor es un proceso que se ejecuta en este entorno aislado. Los contenedores tienen un comando principal que los controla, definido mediante las instrucciones CMD o ENTRYPOINT en el Dockerfile. Esto significa que un contenedor puede:\n\nEjecutar una tarea espec√≠fica y finalizar, como procesar un archivo o ejecutar un script.\nMantenerse en ejecuci√≥n indefinidamente, por ejemplo, para ejecutar un servidor web.\n\nEs importante destacar que los contenedores no son permanentes. Si un contenedor se elimina, la imagen de la cual fue creado permanece intacta, lo que permite iniciar otro contenedor id√©ntico en cualquier momento.\n\n\n\nUna imagen es como el plano o la receta de un contenedor. Es un archivo inmutable que contiene todo lo necesario para ejecutar una aplicaci√≥n: desde el sistema de archivos hasta las configuraciones necesarias.\nLas im√°genes se crean a partir de un Dockerfile, que act√∫a como una plantilla para construirlas. Este archivo define:\n\nLa aplicaci√≥n que se desea ejecutar.\nLas librer√≠as del lenguaje necesarias para su funcionamiento (como Python, Node.js o Java).\nLas librer√≠as del sistema operativo requeridas.\nConfiguraciones espec√≠ficas, como los comandos de arranque (CMD o ENTRYPOINT), puertos que se deben exponer y directorios de trabajo.\n\nUna vez construida la imagen, esta puede ser reutilizada para crear m√∫ltiples contenedores, lo que garantiza consistencia en los entornos de desarrollo, pruebas y producci√≥n.\n\n\n\nEl Dockerfile es un archivo que act√∫a como una receta para construir im√°genes en Docker. Contiene un conjunto de instrucciones secuenciales que le indican a Docker c√≥mo preparar un entorno, desde instalar dependencias hasta copiar archivos o configurar variables de entorno.\nEs una herramienta poderosa porque permite codificar todo el proceso de configuraci√≥n del entorno como texto, asegurando que pueda ser replicado f√°cilmente en cualquier momento y en cualquier lugar.\nEstructura b√°sica de un Dockerfile\nLos Dockerfile suelen comenzar con una instrucci√≥n FROM, que define la imagen base que se utilizar√°. A partir de ah√≠, se agregan las instrucciones necesarias para personalizar esa imagen base seg√∫n las necesidades de la aplicaci√≥n. Entre las instrucciones m√°s comunes se encuentran:\n\nRUN: Ejecuta comandos para instalar dependencias o realizar configuraciones.\nCOPY o ADD: Copian archivos desde el host al contenedor.\nENV: Define variables de entorno.\nCMD o ENTRYPOINT: Especifican el comando que se ejecutar√° al iniciar el contenedor.\n\nEjemplo pr√°ctico\nSupongamos que queremos construir una imagen que sirva una p√°gina web con un servidor Apache. Este ser√≠a el Dockerfile correspondiente:\n# Usamos Ubuntu 22.04 como base\nFROM ubuntu:22.04  \n\n# Actualizamos paquetes e instalamos Apache\nRUN apt-get update && apt-get install -y apache2  \n\n# Copiamos el archivo de nuestra web est√°tica al directorio de Apache\nCOPY index.html /var/www/html/  \n\n# Arrancamos el servidor Apache en primer plano\nCMD [\"apache2ctl\", \"-D\", \"FOREGROUND\"]\nDesglose del ejemplo\n\nFROM ubuntu:22.04 Define que la imagen base ser√° Ubuntu 22.04. Esta es la base sobre la que construiremos todo lo dem√°s.\nRUN apt-get update && apt-get install -y apache2 Actualizamos los paquetes de la distribuci√≥n e instalamos Apache con sus dependencias. Este comando equivale a escribir estas instrucciones en un terminal de Ubuntu.\nCOPY index.html /var/www/html/ Copiamos un archivo local llamado index.html al directorio donde Apache sirve los archivos web.\nCMD [\"apache2ctl\", \"-D\", \"FOREGROUND\"] Definimos el comando que se ejecutar√° cuando el contenedor arranque: iniciar el servidor Apache en modo primer plano (FOREGROUND).\n\nVentajas del Dockerfile\n\nReplicabilidad: Todo el proceso est√° codificado, lo que asegura que cualquiera pueda generar la misma imagen siguiendo el mismo Dockerfile.\nPortabilidad: Puedes construir la misma imagen en cualquier sistema que soporte Docker.\nAutomatizaci√≥n: Permite automatizar la configuraci√≥n de entornos, reduciendo errores humanos.\n\nEn resumen, un Dockerfile es como escribir los pasos que seguir√≠amos manualmente en un sistema operativo, pero los documentamos como c√≥digo para que puedan ser ejecutados autom√°ticamente por Docker. Esto no solo facilita el trabajo en equipo, sino que tambi√©n garantiza entornos consistentes. üöÄ\n\n\n\nDocker Hub es como el mercado central de Docker, donde se almacenan y comparten im√°genes de contenedores. Es un repositorio en l√≠nea donde puedes encontrar im√°genes oficiales creadas por empresas como Python, Nginx o PostgreSQL, adem√°s de im√°genes comunitarias para m√∫ltiples prop√≥sitos. Si necesitas una base para tus proyectos, como un contenedor con Node.js o una base de datos MySQL, Docker Hub ser√° tu mejor aliado. Tambi√©n puedes subir tus propias im√°genes para compartirlas con tu equipo o con la comunidad. Solo necesitas una cuenta para empezar a usar este recurso.\nAhora que conoces qu√© son los contenedores, im√°genes, Dockerfile y Docker Hub, puedes entender c√≥mo estos elementos trabajan juntos para construir entornos de desarrollo eficientes, portables y escalables. üöÄ\nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/docker/05-conceptos-basicos.html#conceptos-b√°sicos-de-docker",
    "href": "tuto_entero/docker/05-conceptos-basicos.html#conceptos-b√°sicos-de-docker",
    "title": "5. Los Conceptos B√°sicos de los Contenedores üëÄ",
    "section": "",
    "text": "Para entender c√≥mo funciona Docker y aprovechar sus capacidades, es importante familiarizarse con algunos conceptos clave. A continuaci√≥n, explicaremos los elementos esenciales que componen esta tecnolog√≠a.\n\n\nUn contenedor es una instancia en ejecuci√≥n de una imagen. Es como una c√°psula autosuficiente dise√±ada para ejecutar una aplicaci√≥n de manera predecible y uniforme, sin importar el entorno donde se encuentre. Siguiendo con la analog√≠a del traje espacial üë©‚ÄçüöÄ, el contenedor encapsula la aplicaci√≥n junto con todas sus dependencias en un entorno aislado.\nEn t√©rminos t√©cnicos, un contenedor es un proceso que se ejecuta en este entorno aislado. Los contenedores tienen un comando principal que los controla, definido mediante las instrucciones CMD o ENTRYPOINT en el Dockerfile. Esto significa que un contenedor puede:\n\nEjecutar una tarea espec√≠fica y finalizar, como procesar un archivo o ejecutar un script.\nMantenerse en ejecuci√≥n indefinidamente, por ejemplo, para ejecutar un servidor web.\n\nEs importante destacar que los contenedores no son permanentes. Si un contenedor se elimina, la imagen de la cual fue creado permanece intacta, lo que permite iniciar otro contenedor id√©ntico en cualquier momento.\n\n\n\nUna imagen es como el plano o la receta de un contenedor. Es un archivo inmutable que contiene todo lo necesario para ejecutar una aplicaci√≥n: desde el sistema de archivos hasta las configuraciones necesarias.\nLas im√°genes se crean a partir de un Dockerfile, que act√∫a como una plantilla para construirlas. Este archivo define:\n\nLa aplicaci√≥n que se desea ejecutar.\nLas librer√≠as del lenguaje necesarias para su funcionamiento (como Python, Node.js o Java).\nLas librer√≠as del sistema operativo requeridas.\nConfiguraciones espec√≠ficas, como los comandos de arranque (CMD o ENTRYPOINT), puertos que se deben exponer y directorios de trabajo.\n\nUna vez construida la imagen, esta puede ser reutilizada para crear m√∫ltiples contenedores, lo que garantiza consistencia en los entornos de desarrollo, pruebas y producci√≥n.\n\n\n\nEl Dockerfile es un archivo que act√∫a como una receta para construir im√°genes en Docker. Contiene un conjunto de instrucciones secuenciales que le indican a Docker c√≥mo preparar un entorno, desde instalar dependencias hasta copiar archivos o configurar variables de entorno.\nEs una herramienta poderosa porque permite codificar todo el proceso de configuraci√≥n del entorno como texto, asegurando que pueda ser replicado f√°cilmente en cualquier momento y en cualquier lugar.\nEstructura b√°sica de un Dockerfile\nLos Dockerfile suelen comenzar con una instrucci√≥n FROM, que define la imagen base que se utilizar√°. A partir de ah√≠, se agregan las instrucciones necesarias para personalizar esa imagen base seg√∫n las necesidades de la aplicaci√≥n. Entre las instrucciones m√°s comunes se encuentran:\n\nRUN: Ejecuta comandos para instalar dependencias o realizar configuraciones.\nCOPY o ADD: Copian archivos desde el host al contenedor.\nENV: Define variables de entorno.\nCMD o ENTRYPOINT: Especifican el comando que se ejecutar√° al iniciar el contenedor.\n\nEjemplo pr√°ctico\nSupongamos que queremos construir una imagen que sirva una p√°gina web con un servidor Apache. Este ser√≠a el Dockerfile correspondiente:\n# Usamos Ubuntu 22.04 como base\nFROM ubuntu:22.04  \n\n# Actualizamos paquetes e instalamos Apache\nRUN apt-get update && apt-get install -y apache2  \n\n# Copiamos el archivo de nuestra web est√°tica al directorio de Apache\nCOPY index.html /var/www/html/  \n\n# Arrancamos el servidor Apache en primer plano\nCMD [\"apache2ctl\", \"-D\", \"FOREGROUND\"]\nDesglose del ejemplo\n\nFROM ubuntu:22.04 Define que la imagen base ser√° Ubuntu 22.04. Esta es la base sobre la que construiremos todo lo dem√°s.\nRUN apt-get update && apt-get install -y apache2 Actualizamos los paquetes de la distribuci√≥n e instalamos Apache con sus dependencias. Este comando equivale a escribir estas instrucciones en un terminal de Ubuntu.\nCOPY index.html /var/www/html/ Copiamos un archivo local llamado index.html al directorio donde Apache sirve los archivos web.\nCMD [\"apache2ctl\", \"-D\", \"FOREGROUND\"] Definimos el comando que se ejecutar√° cuando el contenedor arranque: iniciar el servidor Apache en modo primer plano (FOREGROUND).\n\nVentajas del Dockerfile\n\nReplicabilidad: Todo el proceso est√° codificado, lo que asegura que cualquiera pueda generar la misma imagen siguiendo el mismo Dockerfile.\nPortabilidad: Puedes construir la misma imagen en cualquier sistema que soporte Docker.\nAutomatizaci√≥n: Permite automatizar la configuraci√≥n de entornos, reduciendo errores humanos.\n\nEn resumen, un Dockerfile es como escribir los pasos que seguir√≠amos manualmente en un sistema operativo, pero los documentamos como c√≥digo para que puedan ser ejecutados autom√°ticamente por Docker. Esto no solo facilita el trabajo en equipo, sino que tambi√©n garantiza entornos consistentes. üöÄ\n\n\n\nDocker Hub es como el mercado central de Docker, donde se almacenan y comparten im√°genes de contenedores. Es un repositorio en l√≠nea donde puedes encontrar im√°genes oficiales creadas por empresas como Python, Nginx o PostgreSQL, adem√°s de im√°genes comunitarias para m√∫ltiples prop√≥sitos. Si necesitas una base para tus proyectos, como un contenedor con Node.js o una base de datos MySQL, Docker Hub ser√° tu mejor aliado. Tambi√©n puedes subir tus propias im√°genes para compartirlas con tu equipo o con la comunidad. Solo necesitas una cuenta para empezar a usar este recurso.\nAhora que conoces qu√© son los contenedores, im√°genes, Dockerfile y Docker Hub, puedes entender c√≥mo estos elementos trabajan juntos para construir entornos de desarrollo eficientes, portables y escalables. üöÄ\nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/docker/06-excalidraw.html",
    "href": "tuto_entero/docker/06-excalidraw.html",
    "title": "6. Contenedor de Excalidraw ‚úèÔ∏è",
    "section": "",
    "text": "Para comenzar a utilizar Excalidraw dentro de un contenedor, utilizamos el comando docker run. Este comando nos permite arrancar un contenedor a partir de una imagen espec√≠fica. La sintaxis b√°sica es:\ndocker run &lt;imagen&gt;\nEn este caso vamos a usar el siguiente comando en la terminal:\ndocker run excalidraw/excalidraw\nLa ejecuci√≥n del del comando te deber√≠a dejar la terminal tomada y ver√≠as algo como esto\n\n\n\ncontainer excalidraw\n\n\nAunque no tengamos la imagen descargada, Docker buscar√° autom√°ticamente la imagen en Docker Hub, la descargar√° y arrancar√° el contenedor.\nComo ya te mencion√©, la ejecuci√≥n del comando run dej√≥ tomada la terminal, ahora no puedes utilizarla. Entonces lo que haremos es abrir otra terminal y vamos a consultar los contenedores que est√°n en ejecuci√≥n, con el comando docker ps:\ndocker ps\nY deber√≠as ver el contenedor de excalidraw que est√° en ejecuci√≥n\n\n\n\ndocker ps excali\n\n\nLa informaci√≥n que veras sera:\n\nCONTAINER ID: Es un identificador √∫nico generado autom√°ticamente para cada contenedor, √∫til para realizar acciones espec√≠ficas sobre √©l (como detenerlo o eliminarlo).\nIMAGE: Muestra el nombre y la etiqueta (tag) de la imagen que se utiliz√≥ para crear el contenedor.\nCOMMAND: El comando que se est√° ejecutando como proceso principal del contenedor (normalmente definido en la imagen o sobreescrito al iniciar el contenedor). Ejemplo: /bin/bash.\nCREATED: Indica cu√°nto tiempo ha pasado desde que el contenedor fue creado. Ejemplo: 3 hours ago.\nSTATUS: El estado actual del contenedor, que puede ser:\nUp X minutes/hours/days: El contenedor est√° ejecut√°ndose. Exited (code) X minutes ago: El contenedor se detuvo (con un c√≥digo de salida).\nPORTS: Lista los puertos que est√°n expuestos y mapeados en el contenedor.\nNAMES: El nombre asignado al contenedor, ya sea generado autom√°ticamente o definido por el usuario al crearlo.\n\nSi adem√°s queremos ver todos los contenedores, tanto los que est√°n en ejecuci√≥n como los que han sido detenidos, utilizamos:\ndocker ps -a\nAhora vamos a detener el contenedor que se est√° ejecutando, para eso en la terminal colocamos el siguiente comando\ndocker stop &lt;CONTAINER ID&gt;\nEn este caso el ID del contenedor en ejecuci√≥n es 948ecd7e85a6, por lo que el comando es docker stop 948ecd7e85a6 o tambi√©n, como se muestra en la imagen que est√° a continuaci√≥n, podemos utilizar solo los primeros 3 caracteres del ID.\n\n\n\ndocker stop\n\n\nComo puedes ver, cuando ejecutamos el comando docker ps ya no hay contenedores ejecut√°ndose.\n\n\nEl comando docker run nos permite personalizar el comportamiento de los contenedores mediante diferentes opciones. Algunas de las m√°s comunes son:\n\n-d: Ejecuta el contenedor en segundo plano.\n-p: Mapea un puerto del host a un puerto del contenedor.\n--name: Asigna un nombre personalizado al contenedor.\n--rm: Elimina autom√°ticamente el contenedor una vez detenido.\n-v: Mapea un volumen entre el host y el contenedor.\n-e: Define variables de entorno.\n\n\n\n\nSi queremos ejecutar Excalidraw en segundo plano y mapear un puerto para acceder a √©l desde el navegador, podemos hacerlo con:\ndocker run -d -p 3001:80 --name excalidraw-container excalidraw/excalidraw\n\n-d: Ejecuta el contenedor en segundo plano.\n-p 3001:80: Mapea el puerto 80 del contenedor al puerto 3001 del host, permitiendo acceder a la aplicaci√≥n en http://localhost:3001.\n--name excalidraw-container: Asigna el nombre ‚Äúexcalidraw-container‚Äù al contenedor.\n\nCon este comando, tendremos Excalidraw ejecut√°ndose en un contenedor y accesible desde el navegador.\n\n\n\nexcali interfaz\n\n\nCon un docker pspodemos ver que el contenedor se est√° ejecutando y est√° mapeando el puerto 3001 de nuestra m√°quina al 80 del contenedor.\n\n\n\nexcali ps interfaz\n\n\n\n\n\nComo el contenedor est√° en ejecuci√≥n en segundo plano, podemos consultar sus logs para ver informaci√≥n sobre lo que est√° ocurriendo dentro del contenedor:\ndocker logs excalidraw-container\nO tambi√©n\ndocker logs &lt;CONTAINER ID&gt;\n\n\n\ndocker logs\n\n\nSi queremos seguir los logs en tiempo real:\ndocker logs -f excalidraw-container\nPara desacoplarnos sin detener el contenedor, usamos la combinaci√≥n de teclas Control + P + Q.\n\n\n\nSi deseamos que el contenedor de Excalidraw se reinicie autom√°ticamente en caso de fallo, podemos usar la opci√≥n --restart. Por ejemplo, para reiniciarlo siempre que sea necesario:\ndocker run --restart always -d -p 3001:80 excalidraw/excalidraw\nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/docker/06-excalidraw.html#my-first-excalidraw-container",
    "href": "tuto_entero/docker/06-excalidraw.html#my-first-excalidraw-container",
    "title": "6. Contenedor de Excalidraw ‚úèÔ∏è",
    "section": "",
    "text": "Para comenzar a utilizar Excalidraw dentro de un contenedor, utilizamos el comando docker run. Este comando nos permite arrancar un contenedor a partir de una imagen espec√≠fica. La sintaxis b√°sica es:\ndocker run &lt;imagen&gt;\nEn este caso vamos a usar el siguiente comando en la terminal:\ndocker run excalidraw/excalidraw\nLa ejecuci√≥n del del comando te deber√≠a dejar la terminal tomada y ver√≠as algo como esto\n\n\n\ncontainer excalidraw\n\n\nAunque no tengamos la imagen descargada, Docker buscar√° autom√°ticamente la imagen en Docker Hub, la descargar√° y arrancar√° el contenedor.\nComo ya te mencion√©, la ejecuci√≥n del comando run dej√≥ tomada la terminal, ahora no puedes utilizarla. Entonces lo que haremos es abrir otra terminal y vamos a consultar los contenedores que est√°n en ejecuci√≥n, con el comando docker ps:\ndocker ps\nY deber√≠as ver el contenedor de excalidraw que est√° en ejecuci√≥n\n\n\n\ndocker ps excali\n\n\nLa informaci√≥n que veras sera:\n\nCONTAINER ID: Es un identificador √∫nico generado autom√°ticamente para cada contenedor, √∫til para realizar acciones espec√≠ficas sobre √©l (como detenerlo o eliminarlo).\nIMAGE: Muestra el nombre y la etiqueta (tag) de la imagen que se utiliz√≥ para crear el contenedor.\nCOMMAND: El comando que se est√° ejecutando como proceso principal del contenedor (normalmente definido en la imagen o sobreescrito al iniciar el contenedor). Ejemplo: /bin/bash.\nCREATED: Indica cu√°nto tiempo ha pasado desde que el contenedor fue creado. Ejemplo: 3 hours ago.\nSTATUS: El estado actual del contenedor, que puede ser:\nUp X minutes/hours/days: El contenedor est√° ejecut√°ndose. Exited (code) X minutes ago: El contenedor se detuvo (con un c√≥digo de salida).\nPORTS: Lista los puertos que est√°n expuestos y mapeados en el contenedor.\nNAMES: El nombre asignado al contenedor, ya sea generado autom√°ticamente o definido por el usuario al crearlo.\n\nSi adem√°s queremos ver todos los contenedores, tanto los que est√°n en ejecuci√≥n como los que han sido detenidos, utilizamos:\ndocker ps -a\nAhora vamos a detener el contenedor que se est√° ejecutando, para eso en la terminal colocamos el siguiente comando\ndocker stop &lt;CONTAINER ID&gt;\nEn este caso el ID del contenedor en ejecuci√≥n es 948ecd7e85a6, por lo que el comando es docker stop 948ecd7e85a6 o tambi√©n, como se muestra en la imagen que est√° a continuaci√≥n, podemos utilizar solo los primeros 3 caracteres del ID.\n\n\n\ndocker stop\n\n\nComo puedes ver, cuando ejecutamos el comando docker ps ya no hay contenedores ejecut√°ndose.\n\n\nEl comando docker run nos permite personalizar el comportamiento de los contenedores mediante diferentes opciones. Algunas de las m√°s comunes son:\n\n-d: Ejecuta el contenedor en segundo plano.\n-p: Mapea un puerto del host a un puerto del contenedor.\n--name: Asigna un nombre personalizado al contenedor.\n--rm: Elimina autom√°ticamente el contenedor una vez detenido.\n-v: Mapea un volumen entre el host y el contenedor.\n-e: Define variables de entorno.\n\n\n\n\nSi queremos ejecutar Excalidraw en segundo plano y mapear un puerto para acceder a √©l desde el navegador, podemos hacerlo con:\ndocker run -d -p 3001:80 --name excalidraw-container excalidraw/excalidraw\n\n-d: Ejecuta el contenedor en segundo plano.\n-p 3001:80: Mapea el puerto 80 del contenedor al puerto 3001 del host, permitiendo acceder a la aplicaci√≥n en http://localhost:3001.\n--name excalidraw-container: Asigna el nombre ‚Äúexcalidraw-container‚Äù al contenedor.\n\nCon este comando, tendremos Excalidraw ejecut√°ndose en un contenedor y accesible desde el navegador.\n\n\n\nexcali interfaz\n\n\nCon un docker pspodemos ver que el contenedor se est√° ejecutando y est√° mapeando el puerto 3001 de nuestra m√°quina al 80 del contenedor.\n\n\n\nexcali ps interfaz\n\n\n\n\n\nComo el contenedor est√° en ejecuci√≥n en segundo plano, podemos consultar sus logs para ver informaci√≥n sobre lo que est√° ocurriendo dentro del contenedor:\ndocker logs excalidraw-container\nO tambi√©n\ndocker logs &lt;CONTAINER ID&gt;\n\n\n\ndocker logs\n\n\nSi queremos seguir los logs en tiempo real:\ndocker logs -f excalidraw-container\nPara desacoplarnos sin detener el contenedor, usamos la combinaci√≥n de teclas Control + P + Q.\n\n\n\nSi deseamos que el contenedor de Excalidraw se reinicie autom√°ticamente en caso de fallo, podemos usar la opci√≥n --restart. Por ejemplo, para reiniciarlo siempre que sea necesario:\ndocker run --restart always -d -p 3001:80 excalidraw/excalidraw\nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/docker/02-contenedores.html",
    "href": "tuto_entero/docker/02-contenedores.html",
    "title": "2. Los Contenedores üì¶",
    "section": "",
    "text": "Probablemente hayas o√≠do en alg√∫n momento hablar de Docker (no nos referimos a la marca de ropa), lanzado en 2013 por la empresa del mismo nombre, r√°pidamente se ha convertido en una de las tecnolog√≠as m√°s populares en la inform√°tica. Los contenedores no surgen con Docker, sino que mucho antes con tecnolog√≠as que permiten la virtualizaci√≥n a nivel de sistema operativo como Linux Containers, LXC."
  },
  {
    "objectID": "tuto_entero/docker/02-contenedores.html#diferencias-clave-contenedores-vs-m√°quinas-virtuales",
    "href": "tuto_entero/docker/02-contenedores.html#diferencias-clave-contenedores-vs-m√°quinas-virtuales",
    "title": "2. Los Contenedores üì¶",
    "section": "Diferencias clave: contenedores vs m√°quinas virtuales",
    "text": "Diferencias clave: contenedores vs m√°quinas virtuales\n\n\n\nImagen M√°quinas Virtuales vs Contenedores\n\n\nCuando hablamos de contenedores y m√°quinas virtuales, nos referimos a dos tecnolog√≠as de virtualizaci√≥n que permiten ejecutar m√∫ltiples aplicaciones en un mismo servidor f√≠sico. Sin embargo, sus diferencias son fundamentales y radican en c√≥mo manejan la virtualizaci√≥n, el uso de recursos y su arquitectura.\nEntonces veamos ahora algunas diferencias entre estas tecnolog√≠as\n\nVirtualizaci√≥n y Arquitectura\n\nComo ya vimos, las m√°quinas virtuales (VMs) emulan un hardware completo, incluido un sistema operativo (guest). Esto significa que cada VM act√∫a como si fuera un computador completo y separado, gestionado por el hipervisor, que coordina los recursos del servidor f√≠sico (host).\nPor otro lado, los contenedores virtualizan el sistema operativo en lugar del hardware. En lugar de duplicar sistemas operativos completos, comparten el n√∫cleo del sistema operativo subyacente y a√≠slan cada aplicaci√≥n en su propio entorno. Esto los hace m√°s ligeros y r√°pidos que las m√°quinas virtuales.\n\n\n\nTecnolog√≠a principal\n\nLas VMs dependen de hipervisores, que gestionan el acceso entre el sistema operativo invitado y el sistema operativo host. Este enfoque es robusto, pero introduce una mayor sobrecarga en t√©rminos de rendimiento y uso de recursos.\nLos contenedores, en cambio, utilizan un motor de contenedores o un run-time (como Docker). Este software act√∫a como intermediario, proporcionando y gestionando los recursos necesarios para que las aplicaciones funcionen de manera eficiente.\n\n\n\nTama√±o y uso de recursos\n\nLas m√°quinas virtuales suelen ser pesadas: sus archivos de imagen ocupan varios gigabytes, ya que incluyen un sistema operativo completo. Esto las hace ideales para escenarios donde se requiere emular hardware completo o ejecutar sistemas heterog√©neos.\nLos contenedores, por su parte, son mucho m√°s ligeros, con tama√±os en el rango de megabytes, ya que solo contienen los archivos y configuraciones necesarios para ejecutar una aplicaci√≥n espec√≠fica. Esto permite ejecutar muchos m√°s contenedores en el mismo hardware en comparaci√≥n con VMs.\n\n\n\nVentajas en el mundo real\n\nLas m√°quinas virtuales ofrecen un aislamiento total, siendo ideales para ejecutar aplicaciones que requieren un entorno completamente independiente o para replicar infraestructuras complejas (servidores, redes, bases de datos).\nLos contenedores son perfectos para aplicaciones modernas que necesitan rapidez, escalabilidad y eficiencia, ya que inician en segundos y aprovechan mejor los recursos del hardware.\n\n\n\nCasos en los que los contenedores son √∫tiles\nLos contenedores tienen una amplia gama de aplicaciones. Entre los usos m√°s frecuentes se encuentran:\n\nCreaci√≥n y pruebas de software\nDespliegue de arquitecturas basadas en microservicios\nImplementaci√≥n de soluciones en entornos de nube\nProcesos de Integraci√≥n y Despliegue Continuo (CI/CD)\nSeparaci√≥n de entornos para aplicaciones\nMejora en la escalabilidad y disponibilidad del sistema\nDesarrollo compatible con m√∫ltiples plataformas\n\nEn resumen, las VMs son como construir casas completas en un terreno, con sus propias bases, paredes y techos (sistemas operativos completos), mientras que los contenedores son como departamentos en un edificio que comparten la misma estructura (el n√∫cleo del sistema operativo) pero con espacios completamente independientes. La elecci√≥n entre ambas tecnolog√≠as depender√° de las necesidades de tu proyecto.\nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/docker/03-instalacion.html",
    "href": "tuto_entero/docker/03-instalacion.html",
    "title": "3. Instalaci√≥n de Docker üê≥",
    "section": "",
    "text": "A continuaci√≥n, se explicar√° c√≥mo instalar Docker Desktop para comenzar a experimentar con esta tecnolog√≠a.\n\n\nAntes de descargar nada, es importante asegurarse de que el equipo cumpla con los requisitos:\n\nWindows: Es necesario contar con Windows 10/11 de 64 bits con soporte para WSL 2 (Windows Subsystem for Linux 2). Este subsistema es esencial para el correcto funcionamiento de Docker.\nmacOS: Se requiere macOS 11.0 (Big Sur) o superior. Docker Desktop es compatible tanto con procesadores Intel como con Apple Silicon (M1/M2).\nLinux: Aunque Docker Desktop est√° disponible para Linux, generalmente se recomienda instalar directamente Docker Engine en este sistema.\n\nSi el equipo cumple con estos requisitos, se puede proceder al siguiente paso.\n\n\n\nEs necesario visitar el sitio web oficial de Docker: üëâ https://www.docker.com Una vez all√≠, se debe seleccionar el sistema operativo correspondiente y descargar el instalador. El archivo es liviano, por lo que no deber√≠a tardar mucho en descargarse.\n\n\n\nLa instalaci√≥n var√≠a seg√∫n el sistema operativo. A continuaci√≥n, se describen los pasos para cada uno:\nEn Windows: 1. Ejecutar el archivo descargado (.exe). Si no se tiene configurado WSL 2, el instalador guiar√° en el proceso para habilitarlo. 2. Seguir las instrucciones proporcionadas por el asistente. Es importante marcar la opci√≥n de integraci√≥n con Kubernetes si se planea usarlo en el futuro. 3. Reiniciar el equipo si el instalador lo solicita.\nEn macOS: 1. Abrir el archivo .dmg descargado. 2. Arrastrar el icono de Docker a la carpeta de Aplicaciones. 3. Iniciar Docker Desktop desde la carpeta de Aplicaciones. Se solicitar√°n permisos para realizar configuraciones en el sistema.\nEn Linux: Seguir las instrucciones espec√≠ficas para la distribuci√≥n utilizada, disponibles en la documentaci√≥n oficial de Docker.\n\n\n\nEs momento de comprobar que todo est√° funcionando correctamente. Ahora debes abrir la terminal o consola de comandos y ejecutar el siguiente comando:\ndocker --version\nEsto deber√≠a mostrar la versi√≥n instalada de Docker. Si aparece el n√∫mero de versi√≥n, significa que la instalaci√≥n fue exitosa. üöÄ\n\n\n\ndocker ‚Äìversion en terminal\n\n\nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/docker/03-instalacion.html#instalaci√≥n-de-docker-desktop-paso-a-paso",
    "href": "tuto_entero/docker/03-instalacion.html#instalaci√≥n-de-docker-desktop-paso-a-paso",
    "title": "3. Instalaci√≥n de Docker üê≥",
    "section": "",
    "text": "A continuaci√≥n, se explicar√° c√≥mo instalar Docker Desktop para comenzar a experimentar con esta tecnolog√≠a.\n\n\nAntes de descargar nada, es importante asegurarse de que el equipo cumpla con los requisitos:\n\nWindows: Es necesario contar con Windows 10/11 de 64 bits con soporte para WSL 2 (Windows Subsystem for Linux 2). Este subsistema es esencial para el correcto funcionamiento de Docker.\nmacOS: Se requiere macOS 11.0 (Big Sur) o superior. Docker Desktop es compatible tanto con procesadores Intel como con Apple Silicon (M1/M2).\nLinux: Aunque Docker Desktop est√° disponible para Linux, generalmente se recomienda instalar directamente Docker Engine en este sistema.\n\nSi el equipo cumple con estos requisitos, se puede proceder al siguiente paso.\n\n\n\nEs necesario visitar el sitio web oficial de Docker: üëâ https://www.docker.com Una vez all√≠, se debe seleccionar el sistema operativo correspondiente y descargar el instalador. El archivo es liviano, por lo que no deber√≠a tardar mucho en descargarse.\n\n\n\nLa instalaci√≥n var√≠a seg√∫n el sistema operativo. A continuaci√≥n, se describen los pasos para cada uno:\nEn Windows: 1. Ejecutar el archivo descargado (.exe). Si no se tiene configurado WSL 2, el instalador guiar√° en el proceso para habilitarlo. 2. Seguir las instrucciones proporcionadas por el asistente. Es importante marcar la opci√≥n de integraci√≥n con Kubernetes si se planea usarlo en el futuro. 3. Reiniciar el equipo si el instalador lo solicita.\nEn macOS: 1. Abrir el archivo .dmg descargado. 2. Arrastrar el icono de Docker a la carpeta de Aplicaciones. 3. Iniciar Docker Desktop desde la carpeta de Aplicaciones. Se solicitar√°n permisos para realizar configuraciones en el sistema.\nEn Linux: Seguir las instrucciones espec√≠ficas para la distribuci√≥n utilizada, disponibles en la documentaci√≥n oficial de Docker.\n\n\n\nEs momento de comprobar que todo est√° funcionando correctamente. Ahora debes abrir la terminal o consola de comandos y ejecutar el siguiente comando:\ndocker --version\nEsto deber√≠a mostrar la versi√≥n instalada de Docker. Si aparece el n√∫mero de versi√≥n, significa que la instalaci√≥n fue exitosa. üöÄ\n\n\n\ndocker ‚Äìversion en terminal\n\n\nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/docker/termino.html",
    "href": "tuto_entero/docker/termino.html",
    "title": "9. No es un Adi√≥s es un Hasta Pronto üëã",
    "section": "",
    "text": "Por el momento aqu√≠ terminamos, esperamos que hayas aprendido y puedas utilizar esta tecnolog√≠a. Iremos actualizando el tutorial cuando corresponda y reparando errores para poder mejorar este proyecto. No te desanimes y sigue adelante que eres genial en esto üòä. Si algo no te va, recuerda buscar en stackoverflow, leer la documentaci√≥n, o preguntarle a ChatGPT.\nChau!\nAnterior Siguiente"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bienvenidos",
    "section": "",
    "text": "Descubre una nueva forma de aprendizaje con cursos concisos y pr√°cticos creados para maximizar tu tiempo y conocimiento.\nExplorar los tutos"
  },
  {
    "objectID": "index.html#√∫ltimos-tutos",
    "href": "index.html#√∫ltimos-tutos",
    "title": "Bienvenidos",
    "section": "√öltimos Tutos",
    "text": "√öltimos Tutos\n\n\n\n\n\nDocker\nAprende las bases de Docker para que puedas contenerizar tus apps.\nVer Tuto ‚Üí\n\n\n\n\n\n\n\nAI Companion\nAprende a crear un asistente de IA personalizado usando n8n y tecnolog√≠as modernas.\nVer Tuto ‚Üí"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "tutos.html",
    "href": "tutos.html",
    "title": "Cat√°logo de Tutos",
    "section": "",
    "text": "NotaTutos Disponibles\n\n\n\nExplora nuestra biblioteca de tutos. Cada tuto est√° dise√±ado para ayudarte a desarrollar nuevas habilidades de manera pr√°ctica y efectiva.\n\n\n\n\n\n\n\n\n\n\n\n\n\nHack Yourself: El Prompt Eres T√∫\n\n\n\nagente\n\nasistente\n\nAI\n\ncerebrodigital\n\nNeorenacimiento\n\n\n\n\nBarbarita Lara\n\n\n20 jul 2025\n\n\n\n\n\n\n\n\n\n\nAI Companion\n\n\n\nagente\n\nasistente\n\nAI\n\ncompanion\n\nn8n\n\n\n\n\nBarbarita Lara\n\n\n10 jul 2025\n\n\n\n\n\n\n\n\n\n\nBienvenido al Tuto de Docker\n\n\n\nDocker\n\nTuto Entero\n\n\n\n\nMr.¬†Tuto\n\n\n20 ene 2025\n\n\n\n\n\n\nNo hay resultados"
  },
  {
    "objectID": "tuto_entero/docker/01-virtualizacion.html",
    "href": "tuto_entero/docker/01-virtualizacion.html",
    "title": "1. La Virtualizaci√≥n üë©‚Äçüíª",
    "section": "",
    "text": "Antes de hablar de Docker hablemos de qu√© es la virtualizaci√≥n: Tal como se√±ala AWS:\nAhora bien, por qu√© har√≠as esta virtualizaci√≥n, cu√°l es su importancia. En palabras simples, sacarle provecho al hardware, al fierro, utilizarlo de manera flexible para que rinda de manera √≥ptima para las tareas que se requieren.\nImagina que en la empresa donde trabajas se necesitan tres servidores que se encarguen de las siguientes tareas:\nCada una de estas tareas tiene diferentes requisitos de configuraci√≥n:\nLa soluci√≥n r√°pida ser√≠a adquirir tres servidores f√≠sicos dedicados para cada aplicaci√≥n. La empresa deber√≠a sacar la Visa y pagar esa elevada inversi√≥n en las 3 m√°quinas que por supuesto consumir√≠an electricidad y necesitar√≠an su respectivo mantenimiento. La empresa tendr√≠a esos 3 nuevos servidores, que le generar√≠an costos üíµüíµ, pero solo utilizar√≠a una fracci√≥n de las capacidades de las m√°quinas."
  },
  {
    "objectID": "tuto_entero/docker/01-virtualizacion.html#virtualicemos",
    "href": "tuto_entero/docker/01-virtualizacion.html#virtualicemos",
    "title": "1. La Virtualizaci√≥n üë©‚Äçüíª",
    "section": "Virtualicemos",
    "text": "Virtualicemos\nY aqu√≠ es donde entra la virtualizaci√≥n permitiendo un uso eficiente del hardware, en un solo servidor f√≠sico, la empresaria podr√≠a crear 3 m√°quinas virtuales, s√≠, tendr√≠a en una sola m√°quina f√≠sica las tres m√°quinas que necesita para sus aplicaciones. Cada m√°quina virtual tendr√≠a la configuraci√≥n que necesita, su propio sistema operativo, etc y la empresa donde trabajas se estar√≠a ahorrando el adquirir dos m√°quinas m√°s y los gastos relacionados a ellas.\nComo ya mencionamos a las m√°quinas virtuales ahora definamos qu√© son:\n\nM√°quina Virtual\nNo es nada m√°s ni nada menos que un equipo definido por software que se ejecuta en un equipo f√≠sico con un sistema operativo y recursos inform√°ticos independientes. Tal como le√≠ste, la m√°quina virtual es un computador creado con software dentro de un computador f√≠sico (tangible), a este √∫ltimo se le denomina m√°quina host (host machine), la que proporciona recursos y la m√°quina o m√°quinas virtuales son las m√°quinas invitadas (guest machines). Un host puede ejecutar varios guest, y estos, como ya se se√±al√≥, tienen su propio sistema operativo que puede ser el mismo o diferente del sistema operativo del host.\n\n\nHypervisor\nEn este punto debemos hablar del Hypervisor, que es el software de virtualizaci√≥n, es decir, es quien, instalado en la m√°quina f√≠sica, act√∫a como intermediario entre el hardware o el sistema operativo de esta y las m√°quinas virtuales. Este hipervisor es quien coordina el acceso al entorno f√≠sico, de tal forma que var√≠as m√°quinas virtuales tengan acceso a su propia cuota o porci√≥n de los recursos f√≠sicos del host.\nCon lo anterior ya sabemos los conceptos necesarios para seguir adelante, si tienes mayor curiosidad puedes profundizar m√°s sobre los tipos de hipervisores y los tipos de virtualizaci√≥n existentes.\nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/docker/07-variables-volumenes.html",
    "href": "tuto_entero/docker/07-variables-volumenes.html",
    "title": "7. Variables de Entorno y Vol√∫menes",
    "section": "",
    "text": "Llego el momento de crear nuestra primera app que corra en un contenedor.\n\n\n\n\nCrea la carpeta docker-tutorial\nIngresa a docker-tutorial y crea en una carpeta que se llame app1 y otra llamada data\nAbrela docker-tutorial en tu editor de c√≥digo, yo lo hago en VS Code\nUna vez en el editor, dentro de app1 crea el archivo app.py\nCrea dentro de app1 un archivo txt llamado requirements\nCrea dentro de app1 una carpeta archivo llamado Dockerfile\n\nTu carpeta docker-tutorial se debe ver as√≠\ndocker-tutorial/\n‚îú‚îÄ‚îÄ app1/               \n‚îÇ   ‚îú‚îÄ‚îÄ app.py\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt\n‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile\n|‚îÄ‚îÄ data/\n\n\n\nDesarrollemos app1\n\n\nSigamos, ahora abre en el app.py y copia el c√≥digo que est√° a continuaci√≥n\nimport os\nimport requests\nimport time\n\n# Leer la URL de la API desde la variable de entorno\napi_url = os.getenv('API_URL')\n\n# Ruta al archivo para guardar las bromas\ndata_dir = '/app/data'\ndata_file = os.path.join(data_dir, 'jokes.txt')\n\n# Crear el directorio si no existe\nif not os.path.exists(data_dir):\n    os.makedirs(data_dir)\n\n# Verificar si el archivo existe, si no, lo creamos autom√°ticamente\nif not os.path.exists(data_file):\n    open(data_file, 'w').close()  # Esto crea el archivo vac√≠o si no existe\n\n# Funci√≥n para hacer la solicitud y guardar la broma\ndef fetch_and_save_joke():\n    response = requests.get(api_url)\n    if response.status_code == 200:\n        joke = response.json().get('value', 'No joke found.')\n        print(f\"Broma obtenida: {joke}\")\n\n        # Guardar la broma en el archivo (modo append)\n        with open(data_file, 'a') as file:\n            file.write(joke + '\\n')\n        print(f\"Broma guardada en {data_file}\")\n    else:\n        print(f\"Error al obtener la broma: {response.status_code}\")\n\n# Ejecutar la solicitud cada 1 minuto\nprint(\"Iniciando solicitudes a la API...\")\nwhile True:\n    fetch_and_save_joke()\n    print(\"Esperando 1 minuto para la pr√≥xima solicitud...\")\n    time.sleep(60)\nEl c√≥digo anterior es sencillo, realiza una petici√≥n a la API de don Chuck Norris cada un minuto y guarda una de sus memorables frases en un archivo txt que queda en la carpeta data.\n\n\n\nAbre el archivo requirements y dentro copia y pega lo siguiente:\nrequests\n¬°No olvides guardar!\nEl requirements.txt contiene las dependencias que se utilizar√°n, en este caso requests para hacer las peticiones a la API de don Chuck.\n\n\n\nAhora abre el archivo ```Dockerfile```` y pega lo que est√° aqu√≠ abajo:\n# Usa la imagen base oficial de Python 3.9 en su versi√≥n ligera (slim) para minimizar el tama√±o de la imagen\nFROM python:3.9-slim\n\n# Crea los directorios necesarios dentro del contenedor: \n# - /app para almacenar el c√≥digo de la aplicaci√≥n\n# - /app/data para guardar los datos generados por la aplicaci√≥n (en este caso, bromas)\nRUN mkdir /app /app/data\n\n# Establece el directorio de trabajo dentro del contenedor como /app\n# Todas las operaciones posteriores se realizar√°n desde este directorio\nWORKDIR /app\n\n# Copia el archivo principal del script (app.py) al directorio /app dentro del contenedor\nCOPY app.py /app/\n\n# Copia el archivo de dependencias (requirements.txt) al directorio /app dentro del contenedor\nCOPY requirements.txt /app/\n\n# Instala las dependencias de Python definidas en requirements.txt\nRUN pip install -r requirements.txt\n\n# Define el comando predeterminado que se ejecutar√° cuando el contenedor arranque\nCMD [\"python\", \"app.py\"]\nLee con atenci√≥n el Dockerfile para entender que se hace en cada paso:\n\nFROM python:3.9-slim: Especifica la imagen base. En este caso, usa una imagen ligera de Python 3.9 para reducir el tama√±o del contenedor.\nRUN mkdir /app /app/data: Crea los directorios necesarios: /app: Contendr√° los archivos de la aplicaci√≥n. /app/data: Usado para almacenar datos generados por la aplicaci√≥n.\nWORKDIR /app: Cambia el directorio de trabajo dentro del contenedor a /app. Cualquier comando posterior asumir√° que est√° en este directorio.\nCOPY app.py /app/: Copia el archivo app.py desde tu m√°quina al contenedor, ubic√°ndolo en el directorio /app.\nCOPY requirements.txt /app/: Copia el archivo requirements.txt (que lista las dependencias de Python) desde tu m√°quina al contenedor.\nRUN pip install -r requirements.txt: Instala las bibliotecas de Python especificadas en requirements.txt. Esto asegura que todas las dependencias necesarias est√©n disponibles en el contenedor.\nCMD [\"python\", \"app.py\"]: Define el comando predeterminado para ejecutar cuando el contenedor se inicie. En este caso, ejecuta app.py usando Python.\n\n\n\n\nPrimero recuerda tener Docker Desktop en ejecuci√≥n.\nAhora abre una terminal y navega hasta la carpeta donde est√° el Dockerfile que ser√≠a algo as√≠:\ncd docker-tutorial\ncd app1\nAhora construiremos la imagen, en el mismo terminal ejecuta este comando:\ndocker build -t chuck_norris_generator -f Dockerfile .\nSi todo va bien deber√≠as ver el proceso de creaci√≥n de la imagen de la app1\n\n\n\napp1build\n\n\nAhora haremos correr a ese container! Copia y pega las siguientes instrucciones en tu terminal:\nPara macOS:\ndocker run -it \\\n  --name chuck_norris_generator \\\n  -e API_URL=https://api.chucknorris.io/jokes/random \\\n  -v \"$(pwd)/../data:/app/data\" \\\n  chuck_norris_generator\nPara Windows (PowerShell)\ndocker run -it `\n  --name chuck_norris_generator `\n  -e API_URL=https://api.chucknorris.io/jokes/random `\n  -v ${PWD}/../data:/app/data `\n  chuck_norris_generator\nSi todo va bien, deber√≠as ver los logs de tu contenedor en la terminal y al abrir el jokes.txt deber√≠a estar el primer chiste de don Chuck.\n\n\n\nruncontainer\n\n\n\n\n\n¬°Vamos a desmenuzar este comando para entenderlo paso a paso! Aqu√≠ estamos ejecutando un contenedor de Docker que genera bromas de don Chuck Norris, le asignamos un nombre, le pasamos una variable de entorno para configurar la API y conectamos un volumen para guardar las bromas.\n\n\n\ndocker run -it `\n  --name chuck_norris_generator `\n  -e API_URL=https://api.chucknorris.io/jokes/random `\n  -v ${PWD}/../data:/app/data `\n  chuck_norris_generator\n\n\nEsto le dice a Docker que queremos ejecutar un contenedor basado en una imagen (en este caso, app1).\n\n\n\nEsto significa que el contenedor se ejecutar√° de manera interactiva y mostrar√° la salida directamente en nuestra terminal. B√°sicamente, estamos ‚Äúentrando‚Äù al contenedor.\n\n\n\nAqu√≠ le damos un nombre al contenedor: chuck_norris_generator. Esto es √∫til porque en lugar de lidiar con un CONTAINER ID largo generado por Docker, ahora podemos referirnos a este contenedor por su nombre. Por ejemplo, si queremos detenerlo, podemos usar:\ndocker stop chuck_norris_generator\n\n\n\n¬°Esta es la clave para personalizar el contenedor!\nCon -e, le pasamos una variable de entorno llamada API_URL. Esto le dice al contenedor qu√© API debe usar para obtener las bromas. En este caso, apuntamos a la API de Chuck Norris.\n¬øPor qu√© usar una variable de entorno? - Porque hace que el c√≥digo sea m√°s flexible. Si alguna vez necesitas cambiar la URL de la API, no tendr√°s que modificar el c√≥digo del contenedor. Solo cambias la variable de entorno al ejecutarlo.\n\n\n\nAqu√≠ est√° el truco para guardar datos entre ejecuciones.\nCon -v, estamos creando un volumen. En t√©rminos simples, esto conecta un directorio de tu m√°quina (${PWD}/../data) con un directorio dentro del contenedor (/app/data).\n¬øQu√© significa esto?\n1. ${PWD}/../data:\n- Este es el directorio en tu m√°quina donde se guardar√°n las bromas.\n- ${PWD} obtiene el directorio actual (en este caso, donde est√°s ejecutando el comando), y ../data sube un nivel para buscar la carpeta data.\n\n/app/data:\n\nEs el directorio dentro del contenedor donde se escriben las bromas.\n\nResultado:\nLas bromas generadas por el contenedor se guardan en tu m√°quina local en ../data/jokes.txt. Esto significa que si detienes o eliminas el contenedor, ¬°las bromas seguir√°n ah√≠! üòÇ\n\n\n\n\nPor √∫ltimo, este es el nombre de la imagen Docker que queremos ejecutar.\n\n\n\n\n\nUsamos una variable de entorno (API_URL) para configurar la API desde donde se obtienen las bromas, sin modificar el c√≥digo del contenedor.\nMontamos un volumen (-v) para que los datos generados por el contenedor (las bromas) se guarden en nuestra m√°quina. Esto asegura que las bromas persistan incluso si el contenedor se detiene o elimina.\n\n\n\n\n\nFlexibilidad con -e:\nLas variables de entorno hacen que el contenedor sea reutilizable en diferentes escenarios. Por ejemplo, puedes usar otra API solo cambiando la URL que pasas a API_URL.\nPersistencia con -v:\nLos vol√∫menes permiten que los datos sobrevivan al ciclo de vida del contenedor. Esto es fundamental para aplicaciones que generan o consumen datos.\n\nAhora vamos con la segunda app\n\n\n\n\nSigue los pasos que est√°n a continuaci√≥n\n\nEn la docker-tutorial crea un directorio que se llame app2, abre esta carpeta en tu editor\nEn app2 crea la carpeta static, luego ingresa a ella y crea el archivo style.css\nAhora te devuelves un nivel y en app2 crea el archivo app.py\nCrea dentro de app2 un archivo txt llamado requirements\nCrea dentro de app2 una carpeta archivo llamado Dockerfile\n\nTu carpeta docker-tutorial se debe ver as√≠\ndocker-tutorial/\n‚îú‚îÄ‚îÄ app1/               \n‚îÇ   ‚îú‚îÄ‚îÄ app.py\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt\n‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile\n|‚îÄ‚îÄ data/\n‚îú‚îÄ‚îÄ app2/               \n‚îÇ   ‚îú‚îÄ‚îÄ app.py\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt\n‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile\n‚îÇ   ‚îú‚îÄ‚îÄ static/\n‚îÇ       ‚îú‚îÄ‚îÄstyle.css\n\n\nSigamos, ahora abre en el app.py y copia el c√≥digo que est√° a continuaci√≥n\nfrom flask import Flask, render_template_string\nimport os\nimport requests\n\napp = Flask(__name__)\n\n# Rutas al archivo de bromas\ndata_file = '/app/data/jokes.txt'\n\n# URL de la API de Rick and Morty\n\nrick_and_morty_api = os.getenv('API_URL')\n\n@app.route('/')\ndef show_jokes_and_images():\n    # Leer las bromas desde el archivo\n    if os.path.exists(data_file):\n        with open(data_file, 'r') as file:\n            jokes = file.read().splitlines()\n    else:\n        jokes = [\"No hay bromas disponibles a√∫n.\"]\n\n    # Obtener un personaje aleatorio de Rick and Morty\n    response = requests.get(rick_and_morty_api)\n    if response.status_code == 200:\n        characters = response.json()['results']\n        images = [char['image'] for char in characters]\n    else:\n        images = [\"/static/default.jpg\"]  # Imagen por defecto si falla la API\n\n    # Combinar bromas con im√°genes aleatorias\n    cards = [{\"joke\": joke, \"image\": images[i % len(images)]} for i, joke in enumerate(jokes)]\n\n    # Renderizar HTML\n    html = \"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Chuck Norris Jokes&lt;/title&gt;\n        &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css\"&gt;\n        &lt;link rel=\"stylesheet\" href=\"/static/style.css\"&gt;\n        &lt;script&gt;\n            setInterval(function() {\n                location.reload();\n            }, 60000); // Recargar cada 60 segundos\n        &lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div class=\"container mt-4\"&gt;\n            &lt;h1 class=\"text-center mb-4\"&gt;Chuck Norris Jokes + Rick and Morty&lt;/h1&gt;\n            &lt;div class=\"row\"&gt;\n                {% for card in cards %}\n                &lt;div class=\"col-md-6 mb-3\"&gt;\n                    &lt;div class=\"card\"&gt;\n                        &lt;div class=\"row g-0\"&gt;\n                            &lt;div class=\"col-md-4\"&gt;\n                                &lt;img src=\"{{ card.image }}\" class=\"img-fluid rounded-start\" alt=\"Character\"&gt;\n                            &lt;/div&gt;\n                            &lt;div class=\"col-md-8\"&gt;\n                                &lt;div class=\"card-body\"&gt;\n                                    &lt;p class=\"card-text\"&gt;{{ card.joke }}&lt;/p&gt;\n                                &lt;/div&gt;\n                            &lt;/div&gt;\n                        &lt;/div&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n                {% endfor %}\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n    return render_template_string(html, cards=cards)\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)\nEste c√≥digo crea una aplicaci√≥n web con Flask que combina bromas de Chuck Norris con im√°genes de personajes de Rick and Morty.\n\nLee las bromas de un archivo (jokes.txt), si no existe, muestra un mensaje por defecto.\nObtiene personajes de Rick and Morty desde una API y extrae sus im√°genes. Si la API falla, usa una imagen por defecto.\nCombina bromas e im√°genes en tarjetas (cards) usando un dise√±o horizontal estilo Bootstrap.\nRenderiza un HTML din√°mico que muestra las tarjetas, actualizando la p√°gina autom√°ticamente cada 60 segundos para reflejar cambios en las bromas.\n\n\nEn /static/ agrega cualquier imagen que tengas con el nombre default.jpg, de esta forma si falla la API de Rick and Morty se ver√° una imagen en las tarjetas.\n\n\n\n\nAbre el archivo requirements y dentro copia y pega lo siguiente:\nflask\nrequests\n¬°No olvides guardar!\nEl requirements.txt contiene las dependencias que se utilizar√°n, en este caso requests para crear la aplicaci√≥n web y requests para las peticiones al API de Ricky and Morty\n\n\n\nIngresa a la carpeta static y abre el archivo style.css y pega ah√≠ las lineas de c√≥digo que est√°n a continuaci√≥n:\nbody {\n    font-family: Arial, sans-serif;\n    background-color: #f4f4f4;\n    margin: 0;\n    padding: 0;\n}\n\nh1 {\n    color: #007bff;\n}\n\n.card {\n    border: 1px solid #ddd;\n    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n    border-radius: 10px;\n    overflow: hidden;\n}\n\n.card img {\n    max-height: 150px;\n    object-fit: cover;\n}\n\n.card-text {\n    font-size: 1rem;\n    line-height: 1.5;\n}\n\n\n\nAhora abre el archivo Dockerfile y pega lo que est√° aqu√≠ abajo:\n# Usa una imagen base ligera de Python 3.9\nFROM python:3.9-slim\n\n# Crea los directorios necesarios dentro del contenedor: \n# - /app para almacenar el c√≥digo de la aplicaci√≥n\n# - /app/data para guardar los datos generados por la aplicaci√≥n (en este caso, bromas)\n\nRUN mkdir /app /app/data\n# Establece el directorio de trabajo dentro del contenedor\nWORKDIR /app\n\n# Copia el archivo de requisitos\nCOPY requirements.txt /app/\n\n# Instala las dependencias\nRUN pip install -r requirements.txt\n\n# Copia el c√≥digo de la aplicaci√≥n al contenedor\nCOPY . /app/\n\n# Expone el puerto 5000 para Flask\nEXPOSE 5000\n\n# Comando predeterminado para ejecutar la aplicaci√≥n\nCMD [\"python\", \"app.py\"]\n\n\n\nPrimero recuerda tener Docker Desktop en ejecuci√≥n.\nAhora abre una terminal y navega hasta la carpeta donde est√° el Dockerfile que ser√≠a algo as√≠:\ncd docker-tutorial\ncd app2\nAhora construiremos la imagen, en el mismo terminal ejecuta este comando:\ndocker build -t chuck_norris_web -f Dockerfile .\nDeberias ver algo como lo que est√° en la imagen \nAhora haremos correr a ese container! Copia y pega las siguientes instrucciones en tu terminal:\nPara macOS:\ndocker run -it \\\n  --name chuck_norris_web \\\n  -e API_URL=https://rickandmortyapi.com/api/character \\\n  -p 8081:5000 \\\n  -v \"$(pwd)/../data:/app/data\" \\\n  chuck_norris_web\nPara Windows (PowerShell):\ndocker run -it `\n  --name chuck_norris_web `\n  - e API_URL=https://rickandmortyapi.com/api/character `\n  -p 8081:5000 `\n  -v ${PWD}/../data:/app/data `\n  chuck_norris_web\nSi todo va bien, deber√≠as ver algo como esto en la terminal:\n\n\n\nrun app2\n\n\nY en el navegador ingresa al localhost:8081 y deber√≠as ver algo como esto:\n\n\n\nnavegador\n\n\nY listo, la app2 esta funcionando üéâüéâ ahora tienes dos aplicaciones contenerizadas que comparten un volumen y utilizan variables de entorno, en este caso consultan a dos APIS distintas. ¬øVez el potencial de los contenedores? No tuviste que instalar ninguna dependencia de python, no tuviste que descargar python, este c√≥digo nunca lo ejecutaste en tu VS Code, solo se ejecuto en un ambiente aislado con sus propias dependencias, osea en un contenedor. La app1 se trae las frases y la app2 las muestra junto con una imagen en el navegador.\nTe dejo como deber√≠a estar tu estructura de carpetas \nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/docker/07-variables-volumenes.html#crear-nuestra-primera-app-contenerizada",
    "href": "tuto_entero/docker/07-variables-volumenes.html#crear-nuestra-primera-app-contenerizada",
    "title": "7. Variables de Entorno y Vol√∫menes",
    "section": "",
    "text": "Llego el momento de crear nuestra primera app que corra en un contenedor."
  },
  {
    "objectID": "tuto_entero/docker/07-variables-volumenes.html#docker-tutorial",
    "href": "tuto_entero/docker/07-variables-volumenes.html#docker-tutorial",
    "title": "7. Variables de Entorno y Vol√∫menes",
    "section": "",
    "text": "Crea la carpeta docker-tutorial\nIngresa a docker-tutorial y crea en una carpeta que se llame app1 y otra llamada data\nAbrela docker-tutorial en tu editor de c√≥digo, yo lo hago en VS Code\nUna vez en el editor, dentro de app1 crea el archivo app.py\nCrea dentro de app1 un archivo txt llamado requirements\nCrea dentro de app1 una carpeta archivo llamado Dockerfile\n\nTu carpeta docker-tutorial se debe ver as√≠\ndocker-tutorial/\n‚îú‚îÄ‚îÄ app1/               \n‚îÇ   ‚îú‚îÄ‚îÄ app.py\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt\n‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile\n|‚îÄ‚îÄ data/"
  },
  {
    "objectID": "tuto_entero/docker/07-variables-volumenes.html#app1",
    "href": "tuto_entero/docker/07-variables-volumenes.html#app1",
    "title": "7. Variables de Entorno y Vol√∫menes",
    "section": "",
    "text": "Desarrollemos app1\n\n\nSigamos, ahora abre en el app.py y copia el c√≥digo que est√° a continuaci√≥n\nimport os\nimport requests\nimport time\n\n# Leer la URL de la API desde la variable de entorno\napi_url = os.getenv('API_URL')\n\n# Ruta al archivo para guardar las bromas\ndata_dir = '/app/data'\ndata_file = os.path.join(data_dir, 'jokes.txt')\n\n# Crear el directorio si no existe\nif not os.path.exists(data_dir):\n    os.makedirs(data_dir)\n\n# Verificar si el archivo existe, si no, lo creamos autom√°ticamente\nif not os.path.exists(data_file):\n    open(data_file, 'w').close()  # Esto crea el archivo vac√≠o si no existe\n\n# Funci√≥n para hacer la solicitud y guardar la broma\ndef fetch_and_save_joke():\n    response = requests.get(api_url)\n    if response.status_code == 200:\n        joke = response.json().get('value', 'No joke found.')\n        print(f\"Broma obtenida: {joke}\")\n\n        # Guardar la broma en el archivo (modo append)\n        with open(data_file, 'a') as file:\n            file.write(joke + '\\n')\n        print(f\"Broma guardada en {data_file}\")\n    else:\n        print(f\"Error al obtener la broma: {response.status_code}\")\n\n# Ejecutar la solicitud cada 1 minuto\nprint(\"Iniciando solicitudes a la API...\")\nwhile True:\n    fetch_and_save_joke()\n    print(\"Esperando 1 minuto para la pr√≥xima solicitud...\")\n    time.sleep(60)\nEl c√≥digo anterior es sencillo, realiza una petici√≥n a la API de don Chuck Norris cada un minuto y guarda una de sus memorables frases en un archivo txt que queda en la carpeta data.\n\n\n\nAbre el archivo requirements y dentro copia y pega lo siguiente:\nrequests\n¬°No olvides guardar!\nEl requirements.txt contiene las dependencias que se utilizar√°n, en este caso requests para hacer las peticiones a la API de don Chuck.\n\n\n\nAhora abre el archivo ```Dockerfile```` y pega lo que est√° aqu√≠ abajo:\n# Usa la imagen base oficial de Python 3.9 en su versi√≥n ligera (slim) para minimizar el tama√±o de la imagen\nFROM python:3.9-slim\n\n# Crea los directorios necesarios dentro del contenedor: \n# - /app para almacenar el c√≥digo de la aplicaci√≥n\n# - /app/data para guardar los datos generados por la aplicaci√≥n (en este caso, bromas)\nRUN mkdir /app /app/data\n\n# Establece el directorio de trabajo dentro del contenedor como /app\n# Todas las operaciones posteriores se realizar√°n desde este directorio\nWORKDIR /app\n\n# Copia el archivo principal del script (app.py) al directorio /app dentro del contenedor\nCOPY app.py /app/\n\n# Copia el archivo de dependencias (requirements.txt) al directorio /app dentro del contenedor\nCOPY requirements.txt /app/\n\n# Instala las dependencias de Python definidas en requirements.txt\nRUN pip install -r requirements.txt\n\n# Define el comando predeterminado que se ejecutar√° cuando el contenedor arranque\nCMD [\"python\", \"app.py\"]\nLee con atenci√≥n el Dockerfile para entender que se hace en cada paso:\n\nFROM python:3.9-slim: Especifica la imagen base. En este caso, usa una imagen ligera de Python 3.9 para reducir el tama√±o del contenedor.\nRUN mkdir /app /app/data: Crea los directorios necesarios: /app: Contendr√° los archivos de la aplicaci√≥n. /app/data: Usado para almacenar datos generados por la aplicaci√≥n.\nWORKDIR /app: Cambia el directorio de trabajo dentro del contenedor a /app. Cualquier comando posterior asumir√° que est√° en este directorio.\nCOPY app.py /app/: Copia el archivo app.py desde tu m√°quina al contenedor, ubic√°ndolo en el directorio /app.\nCOPY requirements.txt /app/: Copia el archivo requirements.txt (que lista las dependencias de Python) desde tu m√°quina al contenedor.\nRUN pip install -r requirements.txt: Instala las bibliotecas de Python especificadas en requirements.txt. Esto asegura que todas las dependencias necesarias est√©n disponibles en el contenedor.\nCMD [\"python\", \"app.py\"]: Define el comando predeterminado para ejecutar cuando el contenedor se inicie. En este caso, ejecuta app.py usando Python.\n\n\n\n\nPrimero recuerda tener Docker Desktop en ejecuci√≥n.\nAhora abre una terminal y navega hasta la carpeta donde est√° el Dockerfile que ser√≠a algo as√≠:\ncd docker-tutorial\ncd app1\nAhora construiremos la imagen, en el mismo terminal ejecuta este comando:\ndocker build -t chuck_norris_generator -f Dockerfile .\nSi todo va bien deber√≠as ver el proceso de creaci√≥n de la imagen de la app1\n\n\n\napp1build\n\n\nAhora haremos correr a ese container! Copia y pega las siguientes instrucciones en tu terminal:\nPara macOS:\ndocker run -it \\\n  --name chuck_norris_generator \\\n  -e API_URL=https://api.chucknorris.io/jokes/random \\\n  -v \"$(pwd)/../data:/app/data\" \\\n  chuck_norris_generator\nPara Windows (PowerShell)\ndocker run -it `\n  --name chuck_norris_generator `\n  -e API_URL=https://api.chucknorris.io/jokes/random `\n  -v ${PWD}/../data:/app/data `\n  chuck_norris_generator\nSi todo va bien, deber√≠as ver los logs de tu contenedor en la terminal y al abrir el jokes.txt deber√≠a estar el primer chiste de don Chuck.\n\n\n\nruncontainer\n\n\n\n\n\n¬°Vamos a desmenuzar este comando para entenderlo paso a paso! Aqu√≠ estamos ejecutando un contenedor de Docker que genera bromas de don Chuck Norris, le asignamos un nombre, le pasamos una variable de entorno para configurar la API y conectamos un volumen para guardar las bromas.\n\n\n\ndocker run -it `\n  --name chuck_norris_generator `\n  -e API_URL=https://api.chucknorris.io/jokes/random `\n  -v ${PWD}/../data:/app/data `\n  chuck_norris_generator\n\n\nEsto le dice a Docker que queremos ejecutar un contenedor basado en una imagen (en este caso, app1).\n\n\n\nEsto significa que el contenedor se ejecutar√° de manera interactiva y mostrar√° la salida directamente en nuestra terminal. B√°sicamente, estamos ‚Äúentrando‚Äù al contenedor.\n\n\n\nAqu√≠ le damos un nombre al contenedor: chuck_norris_generator. Esto es √∫til porque en lugar de lidiar con un CONTAINER ID largo generado por Docker, ahora podemos referirnos a este contenedor por su nombre. Por ejemplo, si queremos detenerlo, podemos usar:\ndocker stop chuck_norris_generator\n\n\n\n¬°Esta es la clave para personalizar el contenedor!\nCon -e, le pasamos una variable de entorno llamada API_URL. Esto le dice al contenedor qu√© API debe usar para obtener las bromas. En este caso, apuntamos a la API de Chuck Norris.\n¬øPor qu√© usar una variable de entorno? - Porque hace que el c√≥digo sea m√°s flexible. Si alguna vez necesitas cambiar la URL de la API, no tendr√°s que modificar el c√≥digo del contenedor. Solo cambias la variable de entorno al ejecutarlo.\n\n\n\nAqu√≠ est√° el truco para guardar datos entre ejecuciones.\nCon -v, estamos creando un volumen. En t√©rminos simples, esto conecta un directorio de tu m√°quina (${PWD}/../data) con un directorio dentro del contenedor (/app/data).\n¬øQu√© significa esto?\n1. ${PWD}/../data:\n- Este es el directorio en tu m√°quina donde se guardar√°n las bromas.\n- ${PWD} obtiene el directorio actual (en este caso, donde est√°s ejecutando el comando), y ../data sube un nivel para buscar la carpeta data.\n\n/app/data:\n\nEs el directorio dentro del contenedor donde se escriben las bromas.\n\nResultado:\nLas bromas generadas por el contenedor se guardan en tu m√°quina local en ../data/jokes.txt. Esto significa que si detienes o eliminas el contenedor, ¬°las bromas seguir√°n ah√≠! üòÇ\n\n\n\n\nPor √∫ltimo, este es el nombre de la imagen Docker que queremos ejecutar.\n\n\n\n\n\nUsamos una variable de entorno (API_URL) para configurar la API desde donde se obtienen las bromas, sin modificar el c√≥digo del contenedor.\nMontamos un volumen (-v) para que los datos generados por el contenedor (las bromas) se guarden en nuestra m√°quina. Esto asegura que las bromas persistan incluso si el contenedor se detiene o elimina.\n\n\n\n\n\nFlexibilidad con -e:\nLas variables de entorno hacen que el contenedor sea reutilizable en diferentes escenarios. Por ejemplo, puedes usar otra API solo cambiando la URL que pasas a API_URL.\nPersistencia con -v:\nLos vol√∫menes permiten que los datos sobrevivan al ciclo de vida del contenedor. Esto es fundamental para aplicaciones que generan o consumen datos.\n\nAhora vamos con la segunda app"
  },
  {
    "objectID": "tuto_entero/docker/07-variables-volumenes.html#app2",
    "href": "tuto_entero/docker/07-variables-volumenes.html#app2",
    "title": "7. Variables de Entorno y Vol√∫menes",
    "section": "",
    "text": "Sigue los pasos que est√°n a continuaci√≥n\n\nEn la docker-tutorial crea un directorio que se llame app2, abre esta carpeta en tu editor\nEn app2 crea la carpeta static, luego ingresa a ella y crea el archivo style.css\nAhora te devuelves un nivel y en app2 crea el archivo app.py\nCrea dentro de app2 un archivo txt llamado requirements\nCrea dentro de app2 una carpeta archivo llamado Dockerfile\n\nTu carpeta docker-tutorial se debe ver as√≠\ndocker-tutorial/\n‚îú‚îÄ‚îÄ app1/               \n‚îÇ   ‚îú‚îÄ‚îÄ app.py\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt\n‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile\n|‚îÄ‚îÄ data/\n‚îú‚îÄ‚îÄ app2/               \n‚îÇ   ‚îú‚îÄ‚îÄ app.py\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt\n‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile\n‚îÇ   ‚îú‚îÄ‚îÄ static/\n‚îÇ       ‚îú‚îÄ‚îÄstyle.css\n\n\nSigamos, ahora abre en el app.py y copia el c√≥digo que est√° a continuaci√≥n\nfrom flask import Flask, render_template_string\nimport os\nimport requests\n\napp = Flask(__name__)\n\n# Rutas al archivo de bromas\ndata_file = '/app/data/jokes.txt'\n\n# URL de la API de Rick and Morty\n\nrick_and_morty_api = os.getenv('API_URL')\n\n@app.route('/')\ndef show_jokes_and_images():\n    # Leer las bromas desde el archivo\n    if os.path.exists(data_file):\n        with open(data_file, 'r') as file:\n            jokes = file.read().splitlines()\n    else:\n        jokes = [\"No hay bromas disponibles a√∫n.\"]\n\n    # Obtener un personaje aleatorio de Rick and Morty\n    response = requests.get(rick_and_morty_api)\n    if response.status_code == 200:\n        characters = response.json()['results']\n        images = [char['image'] for char in characters]\n    else:\n        images = [\"/static/default.jpg\"]  # Imagen por defecto si falla la API\n\n    # Combinar bromas con im√°genes aleatorias\n    cards = [{\"joke\": joke, \"image\": images[i % len(images)]} for i, joke in enumerate(jokes)]\n\n    # Renderizar HTML\n    html = \"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Chuck Norris Jokes&lt;/title&gt;\n        &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css\"&gt;\n        &lt;link rel=\"stylesheet\" href=\"/static/style.css\"&gt;\n        &lt;script&gt;\n            setInterval(function() {\n                location.reload();\n            }, 60000); // Recargar cada 60 segundos\n        &lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div class=\"container mt-4\"&gt;\n            &lt;h1 class=\"text-center mb-4\"&gt;Chuck Norris Jokes + Rick and Morty&lt;/h1&gt;\n            &lt;div class=\"row\"&gt;\n                {% for card in cards %}\n                &lt;div class=\"col-md-6 mb-3\"&gt;\n                    &lt;div class=\"card\"&gt;\n                        &lt;div class=\"row g-0\"&gt;\n                            &lt;div class=\"col-md-4\"&gt;\n                                &lt;img src=\"{{ card.image }}\" class=\"img-fluid rounded-start\" alt=\"Character\"&gt;\n                            &lt;/div&gt;\n                            &lt;div class=\"col-md-8\"&gt;\n                                &lt;div class=\"card-body\"&gt;\n                                    &lt;p class=\"card-text\"&gt;{{ card.joke }}&lt;/p&gt;\n                                &lt;/div&gt;\n                            &lt;/div&gt;\n                        &lt;/div&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n                {% endfor %}\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n    return render_template_string(html, cards=cards)\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)\nEste c√≥digo crea una aplicaci√≥n web con Flask que combina bromas de Chuck Norris con im√°genes de personajes de Rick and Morty.\n\nLee las bromas de un archivo (jokes.txt), si no existe, muestra un mensaje por defecto.\nObtiene personajes de Rick and Morty desde una API y extrae sus im√°genes. Si la API falla, usa una imagen por defecto.\nCombina bromas e im√°genes en tarjetas (cards) usando un dise√±o horizontal estilo Bootstrap.\nRenderiza un HTML din√°mico que muestra las tarjetas, actualizando la p√°gina autom√°ticamente cada 60 segundos para reflejar cambios en las bromas.\n\n\nEn /static/ agrega cualquier imagen que tengas con el nombre default.jpg, de esta forma si falla la API de Rick and Morty se ver√° una imagen en las tarjetas.\n\n\n\n\nAbre el archivo requirements y dentro copia y pega lo siguiente:\nflask\nrequests\n¬°No olvides guardar!\nEl requirements.txt contiene las dependencias que se utilizar√°n, en este caso requests para crear la aplicaci√≥n web y requests para las peticiones al API de Ricky and Morty\n\n\n\nIngresa a la carpeta static y abre el archivo style.css y pega ah√≠ las lineas de c√≥digo que est√°n a continuaci√≥n:\nbody {\n    font-family: Arial, sans-serif;\n    background-color: #f4f4f4;\n    margin: 0;\n    padding: 0;\n}\n\nh1 {\n    color: #007bff;\n}\n\n.card {\n    border: 1px solid #ddd;\n    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n    border-radius: 10px;\n    overflow: hidden;\n}\n\n.card img {\n    max-height: 150px;\n    object-fit: cover;\n}\n\n.card-text {\n    font-size: 1rem;\n    line-height: 1.5;\n}\n\n\n\nAhora abre el archivo Dockerfile y pega lo que est√° aqu√≠ abajo:\n# Usa una imagen base ligera de Python 3.9\nFROM python:3.9-slim\n\n# Crea los directorios necesarios dentro del contenedor: \n# - /app para almacenar el c√≥digo de la aplicaci√≥n\n# - /app/data para guardar los datos generados por la aplicaci√≥n (en este caso, bromas)\n\nRUN mkdir /app /app/data\n# Establece el directorio de trabajo dentro del contenedor\nWORKDIR /app\n\n# Copia el archivo de requisitos\nCOPY requirements.txt /app/\n\n# Instala las dependencias\nRUN pip install -r requirements.txt\n\n# Copia el c√≥digo de la aplicaci√≥n al contenedor\nCOPY . /app/\n\n# Expone el puerto 5000 para Flask\nEXPOSE 5000\n\n# Comando predeterminado para ejecutar la aplicaci√≥n\nCMD [\"python\", \"app.py\"]\n\n\n\nPrimero recuerda tener Docker Desktop en ejecuci√≥n.\nAhora abre una terminal y navega hasta la carpeta donde est√° el Dockerfile que ser√≠a algo as√≠:\ncd docker-tutorial\ncd app2\nAhora construiremos la imagen, en el mismo terminal ejecuta este comando:\ndocker build -t chuck_norris_web -f Dockerfile .\nDeberias ver algo como lo que est√° en la imagen \nAhora haremos correr a ese container! Copia y pega las siguientes instrucciones en tu terminal:\nPara macOS:\ndocker run -it \\\n  --name chuck_norris_web \\\n  -e API_URL=https://rickandmortyapi.com/api/character \\\n  -p 8081:5000 \\\n  -v \"$(pwd)/../data:/app/data\" \\\n  chuck_norris_web\nPara Windows (PowerShell):\ndocker run -it `\n  --name chuck_norris_web `\n  - e API_URL=https://rickandmortyapi.com/api/character `\n  -p 8081:5000 `\n  -v ${PWD}/../data:/app/data `\n  chuck_norris_web\nSi todo va bien, deber√≠as ver algo como esto en la terminal:\n\n\n\nrun app2\n\n\nY en el navegador ingresa al localhost:8081 y deber√≠as ver algo como esto:\n\n\n\nnavegador\n\n\nY listo, la app2 esta funcionando üéâüéâ ahora tienes dos aplicaciones contenerizadas que comparten un volumen y utilizan variables de entorno, en este caso consultan a dos APIS distintas. ¬øVez el potencial de los contenedores? No tuviste que instalar ninguna dependencia de python, no tuviste que descargar python, este c√≥digo nunca lo ejecutaste en tu VS Code, solo se ejecuto en un ambiente aislado con sus propias dependencias, osea en un contenedor. La app1 se trae las frases y la app2 las muestra junto con una imagen en el navegador.\nTe dejo como deber√≠a estar tu estructura de carpetas \nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/docker/04-primer-container.html",
    "href": "tuto_entero/docker/04-primer-container.html",
    "title": "4. Mi primer Containerrr üé§",
    "section": "",
    "text": "Es importantisimo que tengas en ejecuci√≥n Docker Desktop, asi que asegurate que le diste doble click y est√° funcionando.\nHello World desde Docker üê≥\nAhora abre la terminal y escribe el siguiente comando\ndocker run hello-world\nSi todo est√° bien deberias ver el Hello from Docker en tu terminal.\n\n\n\nhello world docker\n\n\n¬°Felicidades echaste a andar tu primer contenedor! gracias por revisar este tutorial y nos vemos en el siguiente! üëã\nEstaba bromeando, ya ejecutaste tu primer contenedor, ahora vamos a ver los conceptos b√°sicos para que ejecutemos m√°s contenedores.\nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/docker/04-primer-container.html#recuerdo-cuando-del-container-yo-me-enamor√©",
    "href": "tuto_entero/docker/04-primer-container.html#recuerdo-cuando-del-container-yo-me-enamor√©",
    "title": "4. Mi primer Containerrr üé§",
    "section": "",
    "text": "Es importantisimo que tengas en ejecuci√≥n Docker Desktop, asi que asegurate que le diste doble click y est√° funcionando.\nHello World desde Docker üê≥\nAhora abre la terminal y escribe el siguiente comando\ndocker run hello-world\nSi todo est√° bien deberias ver el Hello from Docker en tu terminal.\n\n\n\nhello world docker\n\n\n¬°Felicidades echaste a andar tu primer contenedor! gracias por revisar este tutorial y nos vemos en el siguiente! üëã\nEstaba bromeando, ya ejecutaste tu primer contenedor, ahora vamos a ver los conceptos b√°sicos para que ejecutemos m√°s contenedores.\nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/docker/index.html",
    "href": "tuto_entero/docker/index.html",
    "title": "Bienvenido al Tuto de Docker",
    "section": "",
    "text": "El primer tuto que tienes a tu disposici√≥n es sobre Docker, en el aprender√°s a crear im√°genes, correr contenedores y orquestarlos con docker-compose. Si no sabes nada de la contenerizaci√≥n aqu√≠ aprender√°s lo esencial para utilizarla en tus proyectos y si ya tienes conocimientos sobre esta tecnolog√≠a, este curso te ayudar√° a consolidar sus principales conceptos.\nSiguiente"
  },
  {
    "objectID": "tuto_entero/docker/index.html#descripci√≥n-del-curso",
    "href": "tuto_entero/docker/index.html#descripci√≥n-del-curso",
    "title": "Bienvenido al Tuto de Docker",
    "section": "",
    "text": "El primer tuto que tienes a tu disposici√≥n es sobre Docker, en el aprender√°s a crear im√°genes, correr contenedores y orquestarlos con docker-compose. Si no sabes nada de la contenerizaci√≥n aqu√≠ aprender√°s lo esencial para utilizarla en tus proyectos y si ya tienes conocimientos sobre esta tecnolog√≠a, este curso te ayudar√° a consolidar sus principales conceptos.\nSiguiente"
  },
  {
    "objectID": "tuto_entero/docker/08-dockercompose.html",
    "href": "tuto_entero/docker/08-dockercompose.html",
    "title": "8. Docker Compose üêô",
    "section": "",
    "text": "¬øQu√© es docker compose y para qu√© sirve?\nDocker Compose es una herramienta que nos permite definir y manejar m√∫ltiples contenedores Docker como una √∫nica aplicaci√≥n. En lugar de correr cada contenedor manualmente con comandos largos, puedes configurar todos tus servicios (contenedores) en un solo archivo YAML (docker-compose.yml) y ejecutarlos juntos con un solo comando.\n\n\n\nBeneficios de Usar Docker Compose\n\nSimplicidad y organizaci√≥n:\n\nTodos los servicios est√°n definidos en un √∫nico archivo.\nF√°cil de leer y entender, especialmente en proyectos con varios contenedores.\n\nAutomatizaci√≥n:\n\nPuedes iniciar, detener y reiniciar todos los servicios con un solo comando.\nDefine relaciones entre los servicios, como cu√°l debe iniciarse primero.\n\nConsistencia:\n\nTodos los miembros del equipo utilizan la misma configuraci√≥n.\nNo necesitas recordar largos comandos docker run.\n\nCompartir recursos:\n\nLos contenedores pueden compartir vol√∫menes y redes, facilitando la comunicaci√≥n y el intercambio de datos.\n\n\n\n\n\n¬øPor qu√© usar docker compose con nuestras apps?\nEn nuestro caso, tenemos dos aplicaciones, app1 y app2, que trabajan juntas:\n\napp1:\n\nGenera bromas de Chuck Norris usando una API y las guarda en un archivo jokes.txt.\nEste archivo se guarda en un volumen compartido (data).\n\napp2:\n\nLee las bromas de jokes.txt y las combina con im√°genes de personajes de Rick and Morty.\nMuestra todo esto en un sitio web estilo Bootstrap.\n\n\nDocker Compose simplifica la forma en que estas dos aplicaciones trabajan juntas. Veamos por qu√©:\n\n\n\nCreando el docker-compose\nEn el mismo directorio docker-tutorial que utilizamos la lecci√≥n anterior, debes crear el archivo llamada docker-compose.yml Asegurate que quede en el mismo nivel que est√°n app1, app2, y data\ndocker-tutorial/\n‚îú‚îÄ‚îÄ app1/               \n‚îÇ   ‚îú‚îÄ‚îÄ app.py\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt\n‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile\n|‚îÄ‚îÄ data/\n‚îú‚îÄ‚îÄ app2/               \n‚îÇ   ‚îú‚îÄ‚îÄ app.py\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt\n‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile\n‚îÇ   ‚îú‚îÄ‚îÄ static/\n‚îÇ       ‚îú‚îÄ‚îÄ style.css\n‚îú‚îÄ‚îÄ docker-compose.yml\n\n\nConfigurando el docker-compose\nAbre con el editor el archivo docker-compose.yml, copia la configuraci√≥n que est√° a continuaci√≥n y pegala en el archivo:\nservices:\n  app1:\n    image: chuck_norris_generator\n    build:\n      context: ./app1\n    environment:\n      - API_URL=https://api.chucknorris.io/jokes/random\n    volumes:\n      - ./data:/app/data  # Monta la carpeta 'data' del host en '/app/data' en el contenedor\n    restart: always\n\n  app2:\n    image: chuck_norris_web\n    build:\n      context: ./app2\n    environment:\n      - API_URL=https://rickandmortyapi.com/api/character\n    ports:\n      - \"8081:5000\"\n    volumes:\n      - ./data:/app/data  # Monta la carpeta 'data' del host en '/app/data' en el contenedor\n    depends_on:\n      - app1  # Asegura que 'app1' se inicie antes de 'app2'\n    restart: always\n\n\nCorramos junto a docker-compose\nAbre una terminal y dirigete a docker-tutorial, y ejecuta el comando docker-compose up --build\ncd docker-turorial\ndocker-compose up --build\nSi toda va bien deber√≠as ver como se est√°n iniciando los contenedores con las dos apps.\n\n\n\ncompose\n\n\nSi abres docker desktop deber√≠as tener un contenedor llamado docker-tutorialy si le das click deber√≠as ver la orquestaci√≥n de los dos contenedores\n\n\n\ndesktop\n\n\nAhora si ingresas al localhost:8081 en tu navegador deber√≠as ver la app funcionando.\n\n\n\nnavegador compose\n\n\n\n\nBeneficios espec√≠ficos para este proyecto\n\nOrquestaci√≥n de app1 y app2:\n\nCon depends_on, nos aseguramos de que app1 (el generador de bromas) se inicie antes que app2 (el visualizador de bromas e im√°genes).\nEsto evita errores de sincronizaci√≥n.\n\nVolumen compartido (data):\n\nAmbos contenedores comparten el volumen data para leer y escribir las bromas.\nCon docker compose, este volumen se configura f√°cilmente en el archivo YAML.\n\nGesti√≥n de Variables de Entorno:\n\nCada app recibe la URL de su respectiva API (Chuck Norris para app1 y Rick and Morty para app2) a trav√©s de variables de entorno.\n\nFacilidad para probar y reiniciar:\n\nSi algo falla, puedes detener y reiniciar todo con:\ndocker-compose down\ndocker-compose up\n\nCompatibilidad de puertos:\n\napp2 expone su contenido en el puerto 8081 para acceder al sitio web.\n\n\n\n\n\nResumiendo‚Ä¶\nUsar Docker Compose con app1 y app2 nos permite:\n\nEjecutar ambas aplicaciones juntas con un solo comando.\nCompartir datos entre los contenedores de manera eficiente.\nAsegurar que app2 no intente funcionar hasta que app1 haya comenzado a generar datos.\nHacer nuestro entorno m√°s f√°cil de manejar y reproducir.\n\nDocker compose no solo simplifica el trabajo, sino que tambi√©n muestra el poder de la orquestaci√≥n y la modularidad en proyectos Docker. üöÄ\nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/01_tallerdebolsillo/termino.html",
    "href": "tuto_entero/01_tallerdebolsillo/termino.html",
    "title": "9. No es un Adi√≥s es un Hasta Pronto üëã",
    "section": "",
    "text": "Por el momento aqu√≠ terminamos, esperamos que hayas aprendido y puedas utilizar esta tecnolog√≠a. Iremos actualizando el tutorial cuando corresponda y reparando errores para poder mejorar este proyecto. No te desanimes y sigue adelante que eres genial en esto üòä. Si algo no te va, recuerda que me puedes encontrar en mi instagram o en mi correo.\nChau!\n\n‚ÄúT√∫ eres el prompt. T√∫ dise√±as tu sistema. T√∫ decides tu prop√≥sito.‚Äù\n\nAnterior Siguiente"
  },
  {
    "objectID": "tuto_entero/01_tallerdebolsillo/index.html",
    "href": "tuto_entero/01_tallerdebolsillo/index.html",
    "title": "Hack Yourself: El Prompt Eres T√∫",
    "section": "",
    "text": "‚ÄúEste no es un curso para aprender a usar IA. Es un viaje para reaprender a ser humano.‚Äù"
  },
  {
    "objectID": "tuto_entero/01_tallerdebolsillo/index.html#descripci√≥n-general-del-tuto",
    "href": "tuto_entero/01_tallerdebolsillo/index.html#descripci√≥n-general-del-tuto",
    "title": "Hack Yourself: El Prompt Eres T√∫",
    "section": "üß≠ Descripci√≥n general del Tuto üçó",
    "text": "üß≠ Descripci√≥n general del Tuto üçó\nHack Yourself: El Prompt Eres T√∫ es un tutorial largo dividido en cap√≠tulos pr√°cticos y reflexivos que nace del Taller de Bolsillo dictado en junio de 2025. Inspirado en Da Vinci y el Renacimiento, mezcla ciencia, arte, filosof√≠a y tecnolog√≠a para ayudarte a dise√±ar tu propio cerebro digital y explorar c√≥mo puedes pensar, crear y decidir con prop√≥sito en tiempos de IA.\nNo necesitas conocimientos t√©cnicos la verdad es que s√≠‚Ä¶pero intentar√© de explicarte paso a paso como ir avanzando. Lo importante es que despiertes tu curiosidad, que tengas ganas de pensar diferente y aprender.\n\nNota: En el Taller de Bolsillo me dieron el feedback de que en la descripci√≥n deber√≠a decir sobre la necesidad de tener conocimiento t√©cnicos, me disculpo si no fui m√°s clara y por no alcanzar a ver todo lo prometido o habernos puesto m√°s t√©cnicos, pero intent√© curbrir los requerimientos que iban llegando cada semana. My bad!\nLa verdad, es que m√°s all√° de las herramientas que veremos en todo este Tuto Largo y del conocimiento t√©cnico que uno tenga, lo que se busca es mostrar la importancia de un buen contexto para conseguir mejores resultados a la hora de resolver problemas o enfrentar la vida, la importancia de la creatividad para lograr desarrollarnos m√°s, as√≠ como, lo fundamental que es dejar un patrimonio digital, de nuestra existencia.\nPor eso estoy haciendo este tutorial :,D"
  },
  {
    "objectID": "tuto_entero/01_tallerdebolsillo/index.html#√≠ndice-de-cap√≠tulos",
    "href": "tuto_entero/01_tallerdebolsillo/index.html#√≠ndice-de-cap√≠tulos",
    "title": "Hack Yourself: El Prompt Eres T√∫",
    "section": "üìö √çndice de cap√≠tulos",
    "text": "üìö √çndice de cap√≠tulos\n\nCap√≠tulo 1 ¬∑ Dise√±a tu Sistema Interior\n\nRedescubre tu mente como un sistema y comienza a construir tu archivo de pensamiento expandido.\n\n\n1.1 Introducci√≥n: El Mapa Invisible\n\n1.2 El Neorenacimiento y t√∫\n\n1.3 Pensar como sistema\n\n1.4 Da Vinci, cuadernos y cerebros extendidos\n\n1.5 Herramientas para construir tu cerebro digital\n\n1.6 Bit√°cora y cierre\n\n‚û°Ô∏è Ir al cap√≠tulo 1\n\n\n\nCap√≠tulo 2 ¬∑ El Prompt Eres T√∫ (pr√≥ximamente)\n\nAprende a conversar con IA desde tu identidad y dise√±a tu primer IA-companion.\n\n\n\n\nCap√≠tulo 3 ¬∑ Dise√±a tu Legado Digital (pr√≥ximamente)\n\nExplora tus datos personales, visual√≠zalos con sentido y construye tu patrimonio digital con prop√≥sito."
  },
  {
    "objectID": "tuto_entero/01_tallerdebolsillo/index.html#c√≥mo-usar-este-tutorial",
    "href": "tuto_entero/01_tallerdebolsillo/index.html#c√≥mo-usar-este-tutorial",
    "title": "Hack Yourself: El Prompt Eres T√∫",
    "section": "‚ú® ¬øC√≥mo usar este tutorial?",
    "text": "‚ú® ¬øC√≥mo usar este tutorial?\n\nSigue cada cap√≠tulo como una etapa de un viaje\nRealiza los ejercicios pr√°cticos\nDocumenta tu aprendizaje en una bit√°cora viva\nUsa las herramientas sugeridas para construir y expandir tu sistema"
  },
  {
    "objectID": "tuto_entero/01_tallerdebolsillo/index.html#herramientas-sugeridas",
    "href": "tuto_entero/01_tallerdebolsillo/index.html#herramientas-sugeridas",
    "title": "Hack Yourself: El Prompt Eres T√∫",
    "section": "üõ† Herramientas sugeridas",
    "text": "üõ† Herramientas sugeridas\n\nObsidian + Excalidraw\nKinopio\nMiro\nNotion\nCuaderno anal√≥gico\nn8n, ChatGPT, Gemini (en cap√≠tulos posteriores)"
  },
  {
    "objectID": "tuto_entero/01_tallerdebolsillo/index.html#manifiesto",
    "href": "tuto_entero/01_tallerdebolsillo/index.html#manifiesto",
    "title": "Hack Yourself: El Prompt Eres T√∫",
    "section": "üåÄ Manifiesto",
    "text": "üåÄ Manifiesto\nT√∫ eres el prompt.\nT√∫ dise√±as tu sistema.\nT√∫ decides tu prop√≥sito.\n¬°Bienvenid@ al Neorenacimiento!\nSiguiente"
  },
  {
    "objectID": "tuto_entero/AI-Companion/01-introduccion.html",
    "href": "tuto_entero/AI-Companion/01-introduccion.html",
    "title": "1. Introducci√≥n",
    "section": "",
    "text": "La inteligencia artificial (IA) ya no es cosa del futuro ‚Äîhoy est√° presente en casi todo: desde asistentes de voz en tu celular üì± hasta sistemas que gestionan empresas enteras üè¢. En este tuto üçó, vamos a explorar una herramienta poderosa y cada vez m√°s com√∫n: el AI Companion ü§ñ. A diferencia de un simple chatbot, un AI Companion puede conversar de forma m√°s natural, recordar informaci√≥n, adaptarse a cada usuario y ayudarte en tareas reales, en tiempo real. Aprender√°s a construir el tuyo usando herramientas como n8n, Supabase, Telegram y modelos de IA como ChatGPT üß†. Todo de forma pr√°ctica, sin necesidad de ser experto en programaci√≥n, siempre considerando los retos √©ticos y t√©cnicos que vienen con esta tecnolog√≠a.\nPrep√°rate para crear un asistente que potencie tus ideas y te acompa√±e en el d√≠a a d√≠a üöÄ."
  },
  {
    "objectID": "tuto_entero/AI-Companion/01-introduccion.html#casos-de-uso-reales-y-posibles-aplicaciones",
    "href": "tuto_entero/AI-Companion/01-introduccion.html#casos-de-uso-reales-y-posibles-aplicaciones",
    "title": "1. Introducci√≥n",
    "section": "Casos de uso reales y posibles aplicaciones",
    "text": "Casos de uso reales y posibles aplicaciones\n\nAtenci√≥n al cliente 24/7.\nTutor acad√©mico personalizado.\nBot de agenda y recordatorios.\nAsistente de viajes, etc.\n\nPara poder aprender como acercarnos al concepto de AI Companion, buscaremos un proyecto aplicado con herramientas de f√°cil uso y te ense√±ar paso a paso a usarlas."
  },
  {
    "objectID": "tuto_entero/AI-Companion/index.html",
    "href": "tuto_entero/AI-Companion/index.html",
    "title": "AI Companion",
    "section": "",
    "text": "En este tuto üçó aprender√°s a crear tu propio AI Companion ü§ñ ‚Äîun asistente virtual inteligente‚Äî combinando herramientas modernas sin necesidad de ser un experto en programaci√≥n. Usaremos n8n üîó, una potente plataforma de automatizaci√≥n visual, para simplificar flujos de trabajo y conectar servicios de manera intuitiva. Adem√°s, integraremos una base de datos en Supabase üóÉÔ∏è, donde gestionaremos la informaci√≥n que nuestro asistente utilizar√° para responder de forma din√°mica y personalizada.\nUno de los aspectos m√°s emocionantes del curso es que aprender√°s a conectar tu AI Companion con Telegram üí¨, permitiendo una interacci√≥n fluida y en tiempo real desde tu celular üì± o computadora üíª. De esta forma, podr√°s conversar directamente con tu asistente, probar funcionalidades y aplicar mejoras al instante.\nA lo largo del tuto üçó exploraremos conceptos clave de la IA conversacional üó£Ô∏è, automatizaci√≥n ‚öôÔ∏è, bases de datos en la nube ‚òÅÔ∏è y dise√±o de flujos inteligentes. Tambi√©n trabajaremos con APIs externas üåê, l√≥gica de decisiones y almacenamiento de contexto para enriquecer las respuestas del asistente.\nAl finalizar, tendr√°s un sistema funcional y escalable üöÄ, listo para ser adaptado a casos reales como atenci√≥n al cliente, asistentes educativos, bots personales y mucho m√°s üßë‚Äçüíºüìö.\nSiguiente"
  },
  {
    "objectID": "tuto_entero/AI-Companion/index.html#descripci√≥n-del-tuto",
    "href": "tuto_entero/AI-Companion/index.html#descripci√≥n-del-tuto",
    "title": "AI Companion",
    "section": "",
    "text": "En este tuto üçó aprender√°s a crear tu propio AI Companion ü§ñ ‚Äîun asistente virtual inteligente‚Äî combinando herramientas modernas sin necesidad de ser un experto en programaci√≥n. Usaremos n8n üîó, una potente plataforma de automatizaci√≥n visual, para simplificar flujos de trabajo y conectar servicios de manera intuitiva. Adem√°s, integraremos una base de datos en Supabase üóÉÔ∏è, donde gestionaremos la informaci√≥n que nuestro asistente utilizar√° para responder de forma din√°mica y personalizada.\nUno de los aspectos m√°s emocionantes del curso es que aprender√°s a conectar tu AI Companion con Telegram üí¨, permitiendo una interacci√≥n fluida y en tiempo real desde tu celular üì± o computadora üíª. De esta forma, podr√°s conversar directamente con tu asistente, probar funcionalidades y aplicar mejoras al instante.\nA lo largo del tuto üçó exploraremos conceptos clave de la IA conversacional üó£Ô∏è, automatizaci√≥n ‚öôÔ∏è, bases de datos en la nube ‚òÅÔ∏è y dise√±o de flujos inteligentes. Tambi√©n trabajaremos con APIs externas üåê, l√≥gica de decisiones y almacenamiento de contexto para enriquecer las respuestas del asistente.\nAl finalizar, tendr√°s un sistema funcional y escalable üöÄ, listo para ser adaptado a casos reales como atenci√≥n al cliente, asistentes educativos, bots personales y mucho m√°s üßë‚Äçüíºüìö.\nSiguiente"
  }
]